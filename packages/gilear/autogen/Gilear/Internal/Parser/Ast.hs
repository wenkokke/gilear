-- WARNING: This module was generated by `tree-sitter-generate-ast`.
--
-- build-depends:
--   , base          >=4.13 && <5
--   , bytestring    >=0.12 && <0.13
--   , containers    >=0.6  && <0.8
--   , mtl           >=2.3  && <2.4
--   , prettyprinter >=1.7  && <1.8
--   , transformers  >=0.6  && <0.7
--   , tree-sitter
--
{-# LANGUAGE DataKinds #-}
{-# LANGUAGE ImportQualifiedPost #-}
{-# LANGUAGE LambdaCase #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE PatternSynonyms #-}
{-# LANGUAGE StandaloneKindSignatures #-}
{-# LANGUAGE TypeData #-}
{-# LANGUAGE TypeFamilies #-}
{-# LANGUAGE UndecidableInstances #-}

module Gilear.Internal.Parser.Ast (
  Sort (..),
  SortSing (..),
  decSortSing,
  SymbolType (..),
  SymbolTypeSing (..),
  decSymbolTypeSing,
  Symbol (..),
  SymbolSing (..),
  decSymbolSing,
  symbolToSymbolType,
  SymbolToSort,
  symbolToSort,
  SomeSymbolSing (..),
  SymbolTable,
  mkSymbolTable,
  type (:<) (..),
  Node (
    SourceFile,
    DeclarationTypeSignature,
    DeclarationFunction,
    ExpressionVariable,
    ExpressionConstructor,
    ExpressionFunctionType,
    ExpressionFunctionApplication,
    ExpressionFunctionAbstraction,
    ExpressionAnnotation,
    ExpressionParentheses,
    ConstructorName,
    PatternList,
    PatternVariable,
    PatternConstructor,
    PatternParentheses,
    VariableName,
    Error,
    Missing,
    SortMismatch
  ),
  nodeToNodeId,
  nodeToRange,
  nodeToChildren,
  SomeNode (..),
  someNodeToNodeId,
  someNodeToRange,
  someNodeToChildren,
  NodeContent (..),
  nodeContentToSymbol,
  Children (..),
  ChildList (..),
  Ast,
  AstCache,
  parseAst,
  checkSort,
) where

import Control.Applicative (Alternative (..), optional)
import Control.Monad (MonadPlus (..))
import Control.Monad.IO.Class (MonadIO (..))
import Control.Monad.Reader (MonadReader, ReaderT (..), asks)
import Control.Monad.State.Strict (MonadState (..), StateT (..), gets, modify')
import Control.Monad.Trans.Maybe (MaybeT (..))
import Data.ByteString.Char8 qualified as BSC
import Data.IntMap.Strict (IntMap)
import Data.IntMap.Strict qualified as IM
import Data.Kind (Type)
import Data.List.NonEmpty (NonEmpty (..))
import Data.Maybe (isJust)
import Data.Type.Equality (type (:~:) (..), type (:~~:) (..))
import Prettyprinter (Doc, Pretty (..), nest, parens, sep)
import TreeSitter (NodeId (..), Range (..))
import TreeSitter qualified as TS

--------------------------------------------------------------------------------
-- Entry point
--------------------------------------------------------------------------------

type Ast = Node SourceFileSort

parseAst :: SymbolTable -> TS.Tree -> AstCache -> IO (Maybe (Ast, AstCache))
parseAst symbolTable tree astCache = do
  rootNode <- TS.treeRootNode tree
  treeCursor <- TS.treeCursorNew rootNode
  let pEnv = PEnv symbolTable treeCursor astCache
  let pState = PState rootNode mempty
  (maybeNode, pState') <- runStateT (runReaderT (runMaybeT (unP p)) pEnv) pState
  pure $ (,newCache pState') <$> maybeNode

--------------------------------------------------------------------------------
-- Sort
--------------------------------------------------------------------------------

type data Sort where
  SourceFileSort :: Sort
  DeclarationSort :: Sort
  ExpressionSort :: Sort
  ConstructorNameSort :: Sort
  PatternListSort :: Sort
  PatternSort :: Sort
  VariableNameSort :: Sort

data SortSing (sort :: Sort) where
  SSourceFileSort :: SortSing SourceFileSort
  SDeclarationSort :: SortSing DeclarationSort
  SExpressionSort :: SortSing ExpressionSort
  SConstructorNameSort :: SortSing ConstructorNameSort
  SPatternListSort :: SortSing PatternListSort
  SPatternSort :: SortSing PatternSort
  SVariableNameSort :: SortSing VariableNameSort

deriving instance Eq (SortSing sort)

deriving instance Show (SortSing sort)

decSortSing :: SortSing sort1 -> SortSing sort2 -> Maybe (sort1 :~: sort2)
decSortSing SSourceFileSort SSourceFileSort = Just Refl
decSortSing SDeclarationSort SDeclarationSort = Just Refl
decSortSing SExpressionSort SExpressionSort = Just Refl
decSortSing SConstructorNameSort SConstructorNameSort = Just Refl
decSortSing SPatternListSort SPatternListSort = Just Refl
decSortSing SPatternSort SPatternSort = Just Refl
decSortSing SVariableNameSort SVariableNameSort = Just Refl
decSortSing _ _ = Nothing

class KnownSort sort where
  sortSing :: SortSing sort

instance KnownSort SourceFileSort where
  sortSing :: SortSing SourceFileSort
  sortSing = SSourceFileSort

instance KnownSort DeclarationSort where
  sortSing :: SortSing DeclarationSort
  sortSing = SDeclarationSort

instance KnownSort ExpressionSort where
  sortSing :: SortSing ExpressionSort
  sortSing = SExpressionSort

instance KnownSort ConstructorNameSort where
  sortSing :: SortSing ConstructorNameSort
  sortSing = SConstructorNameSort

instance KnownSort PatternListSort where
  sortSing :: SortSing PatternListSort
  sortSing = SPatternListSort

instance KnownSort PatternSort where
  sortSing :: SortSing PatternSort
  sortSing = SPatternSort

instance KnownSort VariableNameSort where
  sortSing :: SortSing VariableNameSort
  sortSing = SVariableNameSort

--------------------------------------------------------------------------------
-- SymbolType
--------------------------------------------------------------------------------

type data SymbolType where
  Regular :: SymbolType
  Auxiliary :: SymbolType
  Virtual :: SymbolType

data SymbolTypeSing (symbolType :: SymbolType) where
  SRegular :: SymbolTypeSing Regular
  SAuxiliary :: SymbolTypeSing Auxiliary
  SVirtual :: SymbolTypeSing Virtual

deriving instance Eq (SymbolTypeSing symbolType)

deriving instance Show (SymbolTypeSing symbolType)

decSymbolTypeSing :: SymbolTypeSing symbolType1 -> SymbolTypeSing symbolType2 -> Maybe (symbolType1 :~: symbolType2)
decSymbolTypeSing SRegular SRegular = Just Refl
decSymbolTypeSing SAuxiliary SAuxiliary = Just Refl
decSymbolTypeSing SVirtual SVirtual = Just Refl
decSymbolTypeSing _ _ = Nothing

data IsReal (symbolType :: SymbolType) where
  RegularIsReal :: IsReal Regular
  AuxiliaryIsReal :: IsReal Auxiliary

deriving instance Eq (IsReal symbolType)

deriving instance Show (IsReal symbolType)

symbolTypeIsReal :: SymbolTypeSing symbolType -> Either (IsReal symbolType) (symbolType :~: Virtual)
symbolTypeIsReal = \case
  SRegular -> Left RegularIsReal
  SAuxiliary -> Left AuxiliaryIsReal
  SVirtual -> Right Refl

--------------------------------------------------------------------------------
-- Symbol
--------------------------------------------------------------------------------

type data Symbol (symbolType :: SymbolType) where
  SourceFileSymbol :: (symbolType ~ Regular) => Symbol symbolType
  DeclarationTypeSignatureSymbol :: (symbolType ~ Regular) => Symbol symbolType
  DeclarationFunctionSymbol :: (symbolType ~ Regular) => Symbol symbolType
  ExpressionVariableSymbol :: (symbolType ~ Regular) => Symbol symbolType
  ExpressionConstructorSymbol :: (symbolType ~ Regular) => Symbol symbolType
  ExpressionFunctionTypeSymbol :: (symbolType ~ Regular) => Symbol symbolType
  ExpressionFunctionApplicationSymbol :: (symbolType ~ Regular) => Symbol symbolType
  ExpressionFunctionAbstractionSymbol :: (symbolType ~ Regular) => Symbol symbolType
  ExpressionAnnotationSymbol :: (symbolType ~ Regular) => Symbol symbolType
  ExpressionParenthesesSymbol :: (symbolType ~ Regular) => Symbol symbolType
  ConstructorNameSymbol :: (symbolType ~ Regular) => Symbol symbolType
  PatternListSymbol :: (symbolType ~ Regular) => Symbol symbolType
  PatternVariableSymbol :: (symbolType ~ Regular) => Symbol symbolType
  PatternConstructorSymbol :: (symbolType ~ Regular) => Symbol symbolType
  PatternParenthesesSymbol :: (symbolType ~ Regular) => Symbol symbolType
  VariableNameSymbol :: (symbolType ~ Regular) => Symbol symbolType
  ErrorSymbol :: (symbolType ~ Auxiliary) => Symbol symbolType
  MissingSymbol :: (symbolType ~ Auxiliary) => Symbol symbolType
  SortMismatchSymbol :: (symbolType ~ Virtual) => Symbol symbolType

data SymbolSing (symbolType :: SymbolType) (symbol :: Symbol symbolType) where
  SSourceFileSymbol :: SymbolSing Regular SourceFileSymbol
  SDeclarationTypeSignatureSymbol :: SymbolSing Regular DeclarationTypeSignatureSymbol
  SDeclarationFunctionSymbol :: SymbolSing Regular DeclarationFunctionSymbol
  SExpressionVariableSymbol :: SymbolSing Regular ExpressionVariableSymbol
  SExpressionConstructorSymbol :: SymbolSing Regular ExpressionConstructorSymbol
  SExpressionFunctionTypeSymbol :: SymbolSing Regular ExpressionFunctionTypeSymbol
  SExpressionFunctionApplicationSymbol :: SymbolSing Regular ExpressionFunctionApplicationSymbol
  SExpressionFunctionAbstractionSymbol :: SymbolSing Regular ExpressionFunctionAbstractionSymbol
  SExpressionAnnotationSymbol :: SymbolSing Regular ExpressionAnnotationSymbol
  SExpressionParenthesesSymbol :: SymbolSing Regular ExpressionParenthesesSymbol
  SConstructorNameSymbol :: SymbolSing Regular ConstructorNameSymbol
  SPatternListSymbol :: SymbolSing Regular PatternListSymbol
  SPatternVariableSymbol :: SymbolSing Regular PatternVariableSymbol
  SPatternConstructorSymbol :: SymbolSing Regular PatternConstructorSymbol
  SPatternParenthesesSymbol :: SymbolSing Regular PatternParenthesesSymbol
  SVariableNameSymbol :: SymbolSing Regular VariableNameSymbol
  SErrorSymbol :: SymbolSing Auxiliary ErrorSymbol
  SMissingSymbol :: SymbolSing Auxiliary MissingSymbol
  SSortMismatchSymbol :: SymbolSing Virtual SortMismatchSymbol

deriving instance Eq (SymbolSing sort symbol)

deriving instance Show (SymbolSing sort symbol)

decSymbolSing :: SymbolSing symbolType1 symbol1 -> SymbolSing symbolType2 symbol2 -> Maybe (symbolType1 :~: symbolType2, symbol1 :~~: symbol2)
decSymbolSing SSourceFileSymbol SSourceFileSymbol = Just (Refl, HRefl)
decSymbolSing SDeclarationTypeSignatureSymbol SDeclarationTypeSignatureSymbol = Just (Refl, HRefl)
decSymbolSing SDeclarationFunctionSymbol SDeclarationFunctionSymbol = Just (Refl, HRefl)
decSymbolSing SExpressionVariableSymbol SExpressionVariableSymbol = Just (Refl, HRefl)
decSymbolSing SExpressionConstructorSymbol SExpressionConstructorSymbol = Just (Refl, HRefl)
decSymbolSing SExpressionFunctionTypeSymbol SExpressionFunctionTypeSymbol = Just (Refl, HRefl)
decSymbolSing SExpressionFunctionApplicationSymbol SExpressionFunctionApplicationSymbol = Just (Refl, HRefl)
decSymbolSing SExpressionFunctionAbstractionSymbol SExpressionFunctionAbstractionSymbol = Just (Refl, HRefl)
decSymbolSing SExpressionAnnotationSymbol SExpressionAnnotationSymbol = Just (Refl, HRefl)
decSymbolSing SExpressionParenthesesSymbol SExpressionParenthesesSymbol = Just (Refl, HRefl)
decSymbolSing SConstructorNameSymbol SConstructorNameSymbol = Just (Refl, HRefl)
decSymbolSing SPatternListSymbol SPatternListSymbol = Just (Refl, HRefl)
decSymbolSing SPatternVariableSymbol SPatternVariableSymbol = Just (Refl, HRefl)
decSymbolSing SPatternConstructorSymbol SPatternConstructorSymbol = Just (Refl, HRefl)
decSymbolSing SPatternParenthesesSymbol SPatternParenthesesSymbol = Just (Refl, HRefl)
decSymbolSing SVariableNameSymbol SVariableNameSymbol = Just (Refl, HRefl)
decSymbolSing SErrorSymbol SErrorSymbol = Just (Refl, HRefl)
decSymbolSing SMissingSymbol SMissingSymbol = Just (Refl, HRefl)
decSymbolSing SSortMismatchSymbol SSortMismatchSymbol = Just (Refl, HRefl)
decSymbolSing _ _ = Nothing

data SomeSymbolSing
  = forall (symbolType :: SymbolType) (symbol :: Symbol symbolType).
    SomeSymbolSing !(IsReal symbolType) !(SymbolSing symbolType symbol)

instance Eq SomeSymbolSing where
  (==) :: SomeSymbolSing -> SomeSymbolSing -> Bool
  SomeSymbolSing _isReal1 symbolSing1 == SomeSymbolSing _isReal2 symbolSing2 =
    isJust (decSymbolSing symbolSing1 symbolSing2)

deriving instance Show SomeSymbolSing

pattern SomeRegularSymbolSing :: () => (symbolType ~ Regular) => SymbolSing symbolType symbol -> SomeSymbolSing
pattern SomeRegularSymbolSing symbolSing = SomeSymbolSing RegularIsReal symbolSing

pattern SomeAuxiliarySymbolSing :: () => (symbolType ~ Auxiliary) => SymbolSing symbolType symbol -> SomeSymbolSing
pattern SomeAuxiliarySymbolSing symbolSing = SomeSymbolSing AuxiliaryIsReal symbolSing

--------------------------------------------------------------------------------
-- Getting the symbol types for symbols
--------------------------------------------------------------------------------

symbolToSymbolType :: SymbolSing symbolType symbol -> SymbolTypeSing symbolType
symbolToSymbolType = \case
  SSourceFileSymbol -> SRegular
  SDeclarationTypeSignatureSymbol -> SRegular
  SDeclarationFunctionSymbol -> SRegular
  SExpressionVariableSymbol -> SRegular
  SExpressionConstructorSymbol -> SRegular
  SExpressionFunctionTypeSymbol -> SRegular
  SExpressionFunctionApplicationSymbol -> SRegular
  SExpressionFunctionAbstractionSymbol -> SRegular
  SExpressionAnnotationSymbol -> SRegular
  SExpressionParenthesesSymbol -> SRegular
  SConstructorNameSymbol -> SRegular
  SPatternListSymbol -> SRegular
  SPatternVariableSymbol -> SRegular
  SPatternConstructorSymbol -> SRegular
  SPatternParenthesesSymbol -> SRegular
  SVariableNameSymbol -> SRegular
  SErrorSymbol -> SAuxiliary
  SMissingSymbol -> SAuxiliary
  SSortMismatchSymbol -> SVirtual

--------------------------------------------------------------------------------
-- Inferring sorts for regular symbols
--------------------------------------------------------------------------------

type family SymbolToSort (symbol :: Symbol Regular) :: Sort where
  SymbolToSort SourceFileSymbol = SourceFileSort
  SymbolToSort DeclarationTypeSignatureSymbol = DeclarationSort
  SymbolToSort DeclarationFunctionSymbol = DeclarationSort
  SymbolToSort ExpressionVariableSymbol = ExpressionSort
  SymbolToSort ExpressionConstructorSymbol = ExpressionSort
  SymbolToSort ExpressionFunctionTypeSymbol = ExpressionSort
  SymbolToSort ExpressionFunctionApplicationSymbol = ExpressionSort
  SymbolToSort ExpressionFunctionAbstractionSymbol = ExpressionSort
  SymbolToSort ExpressionAnnotationSymbol = ExpressionSort
  SymbolToSort ExpressionParenthesesSymbol = ExpressionSort
  SymbolToSort ConstructorNameSymbol = ConstructorNameSort
  SymbolToSort PatternListSymbol = PatternListSort
  SymbolToSort PatternVariableSymbol = PatternSort
  SymbolToSort PatternConstructorSymbol = PatternSort
  SymbolToSort PatternParenthesesSymbol = PatternSort
  SymbolToSort VariableNameSymbol = VariableNameSort

symbolToSort :: SymbolSing Regular symbol -> SortSing (SymbolToSort symbol)
symbolToSort = \case
  SSourceFileSymbol -> SSourceFileSort
  SDeclarationTypeSignatureSymbol -> SDeclarationSort
  SDeclarationFunctionSymbol -> SDeclarationSort
  SExpressionVariableSymbol -> SExpressionSort
  SExpressionConstructorSymbol -> SExpressionSort
  SExpressionFunctionTypeSymbol -> SExpressionSort
  SExpressionFunctionApplicationSymbol -> SExpressionSort
  SExpressionFunctionAbstractionSymbol -> SExpressionSort
  SExpressionAnnotationSymbol -> SExpressionSort
  SExpressionParenthesesSymbol -> SExpressionSort
  SConstructorNameSymbol -> SConstructorNameSort
  SPatternListSymbol -> SPatternListSort
  SPatternVariableSymbol -> SPatternSort
  SPatternConstructorSymbol -> SPatternSort
  SPatternParenthesesSymbol -> SPatternSort
  SVariableNameSymbol -> SVariableNameSort

--------------------------------------------------------------------------------
-- Well-sortedness for symbols
--------------------------------------------------------------------------------

type (:<) :: forall (symbolType :: SymbolType). Symbol symbolType -> Sort -> Type
data (:<) symbol sort where
  RegularWellSorted ::
    forall (symbol :: Symbol Regular) (sort :: Sort).
    {-# UNPACK #-} !(SymbolToSort symbol :~: sort) ->
    symbol :< sort
  AuxiliaryWellSorted ::
    forall (symbol :: Symbol Auxiliary) (sort :: Sort).
    symbol :< sort
  VirtualWellSorted ::
    forall (symbol :: Symbol Virtual) (sort :: Sort).
    symbol :< sort

deriving instance Eq (symbol :< sort)

deriving instance Show (symbol :< sort)

--------------------------------------------------------------------------------
-- Nodes
--------------------------------------------------------------------------------

data Node (sort :: Sort)
  = forall (symbolType :: SymbolType) (symbol :: Symbol symbolType).
    Node !(symbol :< sort) !(NodeContent symbolType symbol)

instance Eq (Node sort) where
  (==) :: Node sort -> Node sort -> Bool
  Node isWellSorted1 content1 == Node isWellSorted2 content2 =
    case nodeContentToSymbol content1 `decSymbolSing` nodeContentToSymbol content2 of
      Nothing -> False
      Just (Refl, HRefl) -> isWellSorted1 == isWellSorted2 && content1 == content2

nodeToNodeId :: Node sort -> NodeId
nodeToNodeId = someNodeToNodeId . nodeToSomeNode

nodeToRange :: Node sort -> Range
nodeToRange = someNodeToRange . nodeToSomeNode

nodeToChildren :: Node sort -> [SomeNode]
nodeToChildren = getChildren

data SomeNode
  = forall (symbolType :: SymbolType) (symbol :: Symbol symbolType).
    SomeNode !(IsReal symbolType) !(NodeContent symbolType symbol)

instance Eq SomeNode where
  (==) :: SomeNode -> SomeNode -> Bool
  SomeNode _isReal1 content1 == SomeNode _isReal2 content2 =
    case nodeContentToSymbol content1 `decSymbolSing` nodeContentToSymbol content2 of
      Nothing -> False
      Just (Refl, HRefl) -> content1 == content2

deriving instance Show SomeNode

someNodeToNodeId :: SomeNode -> NodeId
someNodeToNodeId (SomeNode isReal content) = nodeContentToNodeId isReal content

someNodeToRange :: SomeNode -> Range
someNodeToRange (SomeNode isReal content) = nodeContentToRange isReal content

someNodeToChildren :: SomeNode -> [SomeNode]
someNodeToChildren = getChildren

nodeToSomeNode :: Node sort -> SomeNode
nodeToSomeNode (Node _isWellSorted content) =
  case symbolTypeIsReal (symbolToSymbolType (nodeContentToSymbol content)) of
    Left isReal -> SomeNode isReal content
    Right Refl -> let SortMismatchContent someNode = content in someNode

data NodeContent (symbolType :: SymbolType) (symbol :: Symbol symbolType) where
  SourceFileContent ::
    {-# UNPACK #-} !NodeId ->
    {-# UNPACK #-} !Range ->
    !(Children '[[Node DeclarationSort]]) ->
    NodeContent Regular SourceFileSymbol
  DeclarationTypeSignatureContent ::
    {-# UNPACK #-} !NodeId ->
    {-# UNPACK #-} !Range ->
    !(Children '[Node VariableNameSort, Node ExpressionSort]) ->
    NodeContent Regular DeclarationTypeSignatureSymbol
  DeclarationFunctionContent ::
    {-# UNPACK #-} !NodeId ->
    {-# UNPACK #-} !Range ->
    !(Children '[Node VariableNameSort, Maybe (Node PatternListSort), Node ExpressionSort]) ->
    NodeContent Regular DeclarationFunctionSymbol
  ExpressionVariableContent ::
    {-# UNPACK #-} !NodeId ->
    {-# UNPACK #-} !Range ->
    !(Children '[Node VariableNameSort]) ->
    NodeContent Regular ExpressionVariableSymbol
  ExpressionConstructorContent ::
    {-# UNPACK #-} !NodeId ->
    {-# UNPACK #-} !Range ->
    !(Children '[Node ConstructorNameSort]) ->
    NodeContent Regular ExpressionConstructorSymbol
  ExpressionFunctionTypeContent ::
    {-# UNPACK #-} !NodeId ->
    {-# UNPACK #-} !Range ->
    !(Children '[Node ExpressionSort, Node ExpressionSort]) ->
    NodeContent Regular ExpressionFunctionTypeSymbol
  ExpressionFunctionApplicationContent ::
    {-# UNPACK #-} !NodeId ->
    {-# UNPACK #-} !Range ->
    !(Children '[Node ExpressionSort, Node ExpressionSort]) ->
    NodeContent Regular ExpressionFunctionApplicationSymbol
  ExpressionFunctionAbstractionContent ::
    {-# UNPACK #-} !NodeId ->
    {-# UNPACK #-} !Range ->
    !(Children '[Node PatternListSort, Node ExpressionSort]) ->
    NodeContent Regular ExpressionFunctionAbstractionSymbol
  ExpressionAnnotationContent ::
    {-# UNPACK #-} !NodeId ->
    {-# UNPACK #-} !Range ->
    !(Children '[Node ExpressionSort, Node ExpressionSort]) ->
    NodeContent Regular ExpressionAnnotationSymbol
  ExpressionParenthesesContent ::
    {-# UNPACK #-} !NodeId ->
    {-# UNPACK #-} !Range ->
    !(Children '[Node ExpressionSort]) ->
    NodeContent Regular ExpressionParenthesesSymbol
  ConstructorNameContent ::
    {-# UNPACK #-} !NodeId ->
    {-# UNPACK #-} !Range ->
    NodeContent Regular ConstructorNameSymbol
  PatternListContent ::
    {-# UNPACK #-} !NodeId ->
    {-# UNPACK #-} !Range ->
    !(Children '[NonEmpty (Node PatternSort)]) ->
    NodeContent Regular PatternListSymbol
  PatternVariableContent ::
    {-# UNPACK #-} !NodeId ->
    {-# UNPACK #-} !Range ->
    !(Children '[Node VariableNameSort]) ->
    NodeContent Regular PatternVariableSymbol
  PatternConstructorContent ::
    {-# UNPACK #-} !NodeId ->
    {-# UNPACK #-} !Range ->
    !(Children '[Node ConstructorNameSort]) ->
    NodeContent Regular PatternConstructorSymbol
  PatternParenthesesContent ::
    {-# UNPACK #-} !NodeId ->
    {-# UNPACK #-} !Range ->
    !(Children '[Node PatternSort]) ->
    NodeContent Regular PatternParenthesesSymbol
  VariableNameContent ::
    {-# UNPACK #-} !NodeId ->
    {-# UNPACK #-} !Range ->
    NodeContent Regular VariableNameSymbol
  ErrorContent ::
    {-# UNPACK #-} !NodeId ->
    {-# UNPACK #-} !Range ->
    !(Children '[[SomeNode]]) ->
    NodeContent Auxiliary ErrorSymbol
  MissingContent ::
    {-# UNPACK #-} !NodeId ->
    {-# UNPACK #-} !Range ->
    NodeContent Auxiliary MissingSymbol
  SortMismatchContent ::
    !SomeNode ->
    NodeContent Virtual SortMismatchSymbol

deriving instance Eq (NodeContent symbolType symbol)

deriving instance Show (NodeContent symbolType symbol)

nodeContentToSymbol ::
  forall (symbolType :: SymbolType) (symbol :: Symbol symbolType).
  NodeContent symbolType symbol ->
  SymbolSing symbolType symbol
nodeContentToSymbol = \case
  SourceFileContent{} -> SSourceFileSymbol
  DeclarationTypeSignatureContent{} -> SDeclarationTypeSignatureSymbol
  DeclarationFunctionContent{} -> SDeclarationFunctionSymbol
  ExpressionVariableContent{} -> SExpressionVariableSymbol
  ExpressionConstructorContent{} -> SExpressionConstructorSymbol
  ExpressionFunctionTypeContent{} -> SExpressionFunctionTypeSymbol
  ExpressionFunctionApplicationContent{} -> SExpressionFunctionApplicationSymbol
  ExpressionFunctionAbstractionContent{} -> SExpressionFunctionAbstractionSymbol
  ExpressionAnnotationContent{} -> SExpressionAnnotationSymbol
  ExpressionParenthesesContent{} -> SExpressionParenthesesSymbol
  ConstructorNameContent{} -> SConstructorNameSymbol
  PatternListContent{} -> SPatternListSymbol
  PatternVariableContent{} -> SPatternVariableSymbol
  PatternConstructorContent{} -> SPatternConstructorSymbol
  PatternParenthesesContent{} -> SPatternParenthesesSymbol
  VariableNameContent{} -> SVariableNameSymbol
  ErrorContent{} -> SErrorSymbol
  MissingContent{} -> SMissingSymbol
  SortMismatchContent{} -> SSortMismatchSymbol

nodeContentToNodeId ::
  forall (symbolType :: SymbolType) (symbol :: Symbol symbolType).
  IsReal symbolType ->
  NodeContent symbolType symbol ->
  NodeId
nodeContentToNodeId RegularIsReal = \case
  SourceFileContent nodeId _range _children -> nodeId
  DeclarationTypeSignatureContent nodeId _range _children -> nodeId
  DeclarationFunctionContent nodeId _range _children -> nodeId
  ExpressionVariableContent nodeId _range _children -> nodeId
  ExpressionConstructorContent nodeId _range _children -> nodeId
  ExpressionFunctionTypeContent nodeId _range _children -> nodeId
  ExpressionFunctionApplicationContent nodeId _range _children -> nodeId
  ExpressionFunctionAbstractionContent nodeId _range _children -> nodeId
  ExpressionAnnotationContent nodeId _range _children -> nodeId
  ExpressionParenthesesContent nodeId _range _children -> nodeId
  ConstructorNameContent nodeId _range -> nodeId
  PatternListContent nodeId _range _children -> nodeId
  PatternVariableContent nodeId _range _children -> nodeId
  PatternConstructorContent nodeId _range _children -> nodeId
  PatternParenthesesContent nodeId _range _children -> nodeId
  VariableNameContent nodeId _range -> nodeId
nodeContentToNodeId AuxiliaryIsReal = \case
  ErrorContent nodeId _range _children -> nodeId
  MissingContent nodeId _range -> nodeId

nodeContentToRange ::
  forall (symbolType :: SymbolType) (symbol :: Symbol symbolType).
  IsReal symbolType ->
  NodeContent symbolType symbol ->
  Range
nodeContentToRange RegularIsReal = \case
  SourceFileContent _nodeId range _children -> range
  DeclarationTypeSignatureContent _nodeId range _children -> range
  DeclarationFunctionContent _nodeId range _children -> range
  ExpressionVariableContent _nodeId range _children -> range
  ExpressionConstructorContent _nodeId range _children -> range
  ExpressionFunctionTypeContent _nodeId range _children -> range
  ExpressionFunctionApplicationContent _nodeId range _children -> range
  ExpressionFunctionAbstractionContent _nodeId range _children -> range
  ExpressionAnnotationContent _nodeId range _children -> range
  ExpressionParenthesesContent _nodeId range _children -> range
  ConstructorNameContent _nodeId range -> range
  PatternListContent _nodeId range _children -> range
  PatternVariableContent _nodeId range _children -> range
  PatternConstructorContent _nodeId range _children -> range
  PatternParenthesesContent _nodeId range _children -> range
  VariableNameContent _nodeId range -> range
nodeContentToRange AuxiliaryIsReal = \case
  ErrorContent _nodeId range _children -> range
  MissingContent _nodeId range -> range

--------------------------------------------------------------------------------
-- Node Children as Heterogeneous Lists
--------------------------------------------------------------------------------

data ChildList (as :: [Type]) :: Type where
  Nil :: ChildList '[]
  Cons :: !a -> !(ChildList as) -> ChildList (a ': as)

deriving instance Eq (ChildList '[])

deriving instance Show (ChildList '[])

deriving instance (Eq a, Eq (ChildList as)) => Eq (ChildList (a ': as))

deriving instance (Show a, Show (ChildList as)) => Show (ChildList (a ': as))

newtype Children as = Children (ChildList as)

deriving instance (Eq (ChildList as)) => Eq (Children as)

deriving instance (Show (ChildList as)) => Show (Children as)

--------------------------------------------------------------------------------
-- Check Sort
--------------------------------------------------------------------------------

checkSort ::
  SortSing sort ->
  SomeNode ->
  Maybe (Node sort)
checkSort sort (SomeNode _isReal content) = do
  let symbol = nodeContentToSymbol content
  let symbolType = symbolToSymbolType symbol
  case symbolType of
    SRegular ->
      case decSortSing sort (symbolToSort symbol) of
        Just Refl -> pure $ Node (RegularWellSorted Refl) content
        Nothing -> Nothing
    SAuxiliary -> pure $ Node AuxiliaryWellSorted content

--------------------------------------------------------------------------------
-- Difference Lists
--------------------------------------------------------------------------------

newtype DList a = DList ([a] -> [a])

instance Semigroup (DList a) where
  (<>) :: DList a -> DList a -> DList a
  DList xs <> DList ys = DList (xs . ys)

instance Monoid (DList a) where
  mempty :: DList a
  mempty = DList id

instance Functor DList where
  fmap :: (a -> b) -> DList a -> DList b
  fmap f = foldMap (singleton . f)

instance Foldable DList where
  foldMap :: (Monoid m) => (a -> m) -> DList a -> m
  foldMap f = foldMap f . toList

singleton :: a -> DList a
singleton x = DList (x :)

toList :: DList a -> [a]
toList (DList xs) = xs []

--------------------------------------------------------------------------------
-- Node Children as Lists
--------------------------------------------------------------------------------

{-# SPECIALIZE getChildren :: Node sort -> [SomeNode] #-}
{-# SPECIALIZE getChildren :: SomeNode -> [SomeNode] #-}
getChildren :: (HasNodes a) => a -> [SomeNode]
getChildren = toList . foldMap getNodesDList . getNodesDList

{-# SPECIALIZE getNodes :: Node sort -> [SomeNode] #-}
{-# SPECIALIZE getNodes :: SomeNode -> [SomeNode] #-}
getNodes :: (HasNodes a) => a -> [SomeNode]
getNodes = toList . getNodesDList

class HasNodes a where
  getNodesDList :: a -> DList SomeNode

instance HasNodes (ChildList '[]) where
  getNodesDList :: ChildList '[] -> DList SomeNode
  getNodesDList Nil = mempty

instance (HasNodes a, HasNodes (ChildList as)) => HasNodes (ChildList (a ': as)) where
  getNodesDList :: ChildList (a ': as) -> DList SomeNode
  getNodesDList (Cons x xs) = getNodesDList x <> getNodesDList xs

instance (HasNodes (ChildList as)) => HasNodes (Children as) where
  getNodesDList :: Children as -> DList SomeNode
  getNodesDList (Children xs) = getNodesDList xs

instance HasNodes () where
  getNodesDList :: () -> DList SomeNode
  getNodesDList () = mempty

instance (HasNodes a, HasNodes b) => HasNodes (a, b) where
  getNodesDList :: (a, b) -> DList SomeNode
  getNodesDList (x, y) = getNodesDList x <> getNodesDList y

instance (HasNodes a, HasNodes b) => HasNodes (Either a b) where
  getNodesDList :: Either a b -> DList SomeNode
  getNodesDList = either getNodesDList getNodesDList

instance (Foldable t, HasNodes a) => HasNodes (t a) where
  getNodesDList :: t a -> DList SomeNode
  getNodesDList = foldMap getNodesDList

instance HasNodes (Node sort) where
  getNodesDList :: Node sort -> DList SomeNode
  getNodesDList = getNodesDList . nodeToSomeNode

instance HasNodes SomeNode where
  getNodesDList :: SomeNode -> DList SomeNode
  getNodesDList = singleton

instance HasNodes (NodeContent symbolType symbol) where
  getNodesDList :: NodeContent symbolType symbol -> DList SomeNode
  getNodesDList = \case
    SourceFileContent _nodeId _range _children -> getNodesDList _children
    DeclarationTypeSignatureContent _nodeId _range _children -> getNodesDList _children
    DeclarationFunctionContent _nodeId _range _children -> getNodesDList _children
    ExpressionVariableContent _nodeId _range _children -> getNodesDList _children
    ExpressionConstructorContent _nodeId _range _children -> getNodesDList _children
    ExpressionFunctionTypeContent _nodeId _range _children -> getNodesDList _children
    ExpressionFunctionApplicationContent _nodeId _range _children -> getNodesDList _children
    ExpressionFunctionAbstractionContent _nodeId _range _children -> getNodesDList _children
    ExpressionAnnotationContent _nodeId _range _children -> getNodesDList _children
    ExpressionParenthesesContent _nodeId _range _children -> getNodesDList _children
    ConstructorNameContent _nodeId _range -> mempty
    PatternListContent _nodeId _range _children -> getNodesDList _children
    PatternVariableContent _nodeId _range _children -> getNodesDList _children
    PatternConstructorContent _nodeId _range _children -> getNodesDList _children
    PatternParenthesesContent _nodeId _range _children -> getNodesDList _children
    VariableNameContent _nodeId _range -> mempty
    ErrorContent _nodeId _range _children -> getNodesDList _children
    MissingContent _nodeId _range -> mempty
    SortMismatchContent _children -> getNodesDList _children

--------------------------------------------------------------------------------
-- Pattern Synonyms
--------------------------------------------------------------------------------

pattern SourceFile :: () => (sort ~ SourceFileSort) => NodeId -> Range -> [Node DeclarationSort] -> Node sort
pattern SourceFile nodeId range nodeChild0 =
  Node (RegularWellSorted Refl) (SourceFileContent nodeId range (Children (Cons nodeChild0 Nil)))

pattern DeclarationTypeSignature :: () => (sort ~ DeclarationSort) => NodeId -> Range -> Node VariableNameSort -> Node ExpressionSort -> Node sort
pattern DeclarationTypeSignature nodeId range nodeChild0 nodeChild1 =
  Node (RegularWellSorted Refl) (DeclarationTypeSignatureContent nodeId range (Children (Cons nodeChild0 (Cons nodeChild1 Nil))))

pattern DeclarationFunction :: () => (sort ~ DeclarationSort) => NodeId -> Range -> Node VariableNameSort -> Maybe (Node PatternListSort) -> Node ExpressionSort -> Node sort
pattern DeclarationFunction nodeId range nodeChild0 nodeChild1 nodeChild2 =
  Node (RegularWellSorted Refl) (DeclarationFunctionContent nodeId range (Children (Cons nodeChild0 (Cons nodeChild1 (Cons nodeChild2 Nil)))))

pattern ExpressionVariable :: () => (sort ~ ExpressionSort) => NodeId -> Range -> Node VariableNameSort -> Node sort
pattern ExpressionVariable nodeId range nodeChild0 =
  Node (RegularWellSorted Refl) (ExpressionVariableContent nodeId range (Children (Cons nodeChild0 Nil)))

pattern ExpressionConstructor :: () => (sort ~ ExpressionSort) => NodeId -> Range -> Node ConstructorNameSort -> Node sort
pattern ExpressionConstructor nodeId range nodeChild0 =
  Node (RegularWellSorted Refl) (ExpressionConstructorContent nodeId range (Children (Cons nodeChild0 Nil)))

pattern ExpressionFunctionType :: () => (sort ~ ExpressionSort) => NodeId -> Range -> Node ExpressionSort -> Node ExpressionSort -> Node sort
pattern ExpressionFunctionType nodeId range nodeChild0 nodeChild1 =
  Node (RegularWellSorted Refl) (ExpressionFunctionTypeContent nodeId range (Children (Cons nodeChild0 (Cons nodeChild1 Nil))))

pattern ExpressionFunctionApplication :: () => (sort ~ ExpressionSort) => NodeId -> Range -> Node ExpressionSort -> Node ExpressionSort -> Node sort
pattern ExpressionFunctionApplication nodeId range nodeChild0 nodeChild1 =
  Node (RegularWellSorted Refl) (ExpressionFunctionApplicationContent nodeId range (Children (Cons nodeChild0 (Cons nodeChild1 Nil))))

pattern ExpressionFunctionAbstraction :: () => (sort ~ ExpressionSort) => NodeId -> Range -> Node PatternListSort -> Node ExpressionSort -> Node sort
pattern ExpressionFunctionAbstraction nodeId range nodeChild0 nodeChild1 =
  Node (RegularWellSorted Refl) (ExpressionFunctionAbstractionContent nodeId range (Children (Cons nodeChild0 (Cons nodeChild1 Nil))))

pattern ExpressionAnnotation :: () => (sort ~ ExpressionSort) => NodeId -> Range -> Node ExpressionSort -> Node ExpressionSort -> Node sort
pattern ExpressionAnnotation nodeId range nodeChild0 nodeChild1 =
  Node (RegularWellSorted Refl) (ExpressionAnnotationContent nodeId range (Children (Cons nodeChild0 (Cons nodeChild1 Nil))))

pattern ExpressionParentheses :: () => (sort ~ ExpressionSort) => NodeId -> Range -> Node ExpressionSort -> Node sort
pattern ExpressionParentheses nodeId range nodeChild0 =
  Node (RegularWellSorted Refl) (ExpressionParenthesesContent nodeId range (Children (Cons nodeChild0 Nil)))

pattern ConstructorName :: () => (sort ~ ConstructorNameSort) => NodeId -> Range -> Node sort
pattern ConstructorName nodeId range =
  Node (RegularWellSorted Refl) (ConstructorNameContent nodeId range)

pattern PatternList :: () => (sort ~ PatternListSort) => NodeId -> Range -> NonEmpty (Node PatternSort) -> Node sort
pattern PatternList nodeId range nodeChild0 =
  Node (RegularWellSorted Refl) (PatternListContent nodeId range (Children (Cons nodeChild0 Nil)))

pattern PatternVariable :: () => (sort ~ PatternSort) => NodeId -> Range -> Node VariableNameSort -> Node sort
pattern PatternVariable nodeId range nodeChild0 =
  Node (RegularWellSorted Refl) (PatternVariableContent nodeId range (Children (Cons nodeChild0 Nil)))

pattern PatternConstructor :: () => (sort ~ PatternSort) => NodeId -> Range -> Node ConstructorNameSort -> Node sort
pattern PatternConstructor nodeId range nodeChild0 =
  Node (RegularWellSorted Refl) (PatternConstructorContent nodeId range (Children (Cons nodeChild0 Nil)))

pattern PatternParentheses :: () => (sort ~ PatternSort) => NodeId -> Range -> Node PatternSort -> Node sort
pattern PatternParentheses nodeId range nodeChild0 =
  Node (RegularWellSorted Refl) (PatternParenthesesContent nodeId range (Children (Cons nodeChild0 Nil)))

pattern VariableName :: () => (sort ~ VariableNameSort) => NodeId -> Range -> Node sort
pattern VariableName nodeId range =
  Node (RegularWellSorted Refl) (VariableNameContent nodeId range)

pattern Error :: NodeId -> Range -> [SomeNode] -> Node sort
pattern Error nodeId range nodeChild0 =
  Node AuxiliaryWellSorted (ErrorContent nodeId range (Children (Cons nodeChild0 Nil)))

pattern Missing :: NodeId -> Range -> Node sort
pattern Missing nodeId range =
  Node AuxiliaryWellSorted (MissingContent nodeId range)

pattern SortMismatch :: SomeNode -> Node sort
pattern SortMismatch nodeChild0 =
  Node VirtualWellSorted (SortMismatchContent nodeChild0)

{-# COMPLETE
  SourceFile
  , DeclarationTypeSignature
  , DeclarationFunction
  , ExpressionVariable
  , ExpressionConstructor
  , ExpressionFunctionType
  , ExpressionFunctionApplication
  , ExpressionFunctionAbstraction
  , ExpressionAnnotation
  , ExpressionParentheses
  , ConstructorName
  , PatternList
  , PatternVariable
  , PatternConstructor
  , PatternParentheses
  , VariableName
  , Error
  , Missing
  , SortMismatch
  #-}

--------------------------------------------------------------------------------
-- Show Instance using Pattern Synonyms
--------------------------------------------------------------------------------

instance Show (Node sort) where
  showsPrec :: Int -> Node sort -> ShowS
  showsPrec prec =
    showParen (prec > 10) . \case
      SourceFile nodeId range nodeChild0 ->
        showString "SourceFile " . showsPrec 11 nodeId . showChar ' ' . showsPrec 11 range . showChar ' ' . showsPrec 11 nodeChild0
      DeclarationTypeSignature nodeId range nodeChild0 nodeChild1 ->
        showString "DeclarationTypeSignature " . showsPrec 11 nodeId . showChar ' ' . showsPrec 11 range . showChar ' ' . showsPrec 11 nodeChild0 . showChar ' ' . showsPrec 11 nodeChild1
      DeclarationFunction nodeId range nodeChild0 nodeChild1 nodeChild2 ->
        showString "DeclarationFunction " . showsPrec 11 nodeId . showChar ' ' . showsPrec 11 range . showChar ' ' . showsPrec 11 nodeChild0 . showChar ' ' . showsPrec 11 nodeChild1 . showChar ' ' . showsPrec 11 nodeChild2
      ExpressionVariable nodeId range nodeChild0 ->
        showString "ExpressionVariable " . showsPrec 11 nodeId . showChar ' ' . showsPrec 11 range . showChar ' ' . showsPrec 11 nodeChild0
      ExpressionConstructor nodeId range nodeChild0 ->
        showString "ExpressionConstructor " . showsPrec 11 nodeId . showChar ' ' . showsPrec 11 range . showChar ' ' . showsPrec 11 nodeChild0
      ExpressionFunctionType nodeId range nodeChild0 nodeChild1 ->
        showString "ExpressionFunctionType " . showsPrec 11 nodeId . showChar ' ' . showsPrec 11 range . showChar ' ' . showsPrec 11 nodeChild0 . showChar ' ' . showsPrec 11 nodeChild1
      ExpressionFunctionApplication nodeId range nodeChild0 nodeChild1 ->
        showString "ExpressionFunctionApplication " . showsPrec 11 nodeId . showChar ' ' . showsPrec 11 range . showChar ' ' . showsPrec 11 nodeChild0 . showChar ' ' . showsPrec 11 nodeChild1
      ExpressionFunctionAbstraction nodeId range nodeChild0 nodeChild1 ->
        showString "ExpressionFunctionAbstraction " . showsPrec 11 nodeId . showChar ' ' . showsPrec 11 range . showChar ' ' . showsPrec 11 nodeChild0 . showChar ' ' . showsPrec 11 nodeChild1
      ExpressionAnnotation nodeId range nodeChild0 nodeChild1 ->
        showString "ExpressionAnnotation " . showsPrec 11 nodeId . showChar ' ' . showsPrec 11 range . showChar ' ' . showsPrec 11 nodeChild0 . showChar ' ' . showsPrec 11 nodeChild1
      ExpressionParentheses nodeId range nodeChild0 ->
        showString "ExpressionParentheses " . showsPrec 11 nodeId . showChar ' ' . showsPrec 11 range . showChar ' ' . showsPrec 11 nodeChild0
      ConstructorName nodeId range ->
        showString "ConstructorName " . showsPrec 11 nodeId . showChar ' ' . showsPrec 11 range
      PatternList nodeId range nodeChild0 ->
        showString "PatternList " . showsPrec 11 nodeId . showChar ' ' . showsPrec 11 range . showChar ' ' . showsPrec 11 nodeChild0
      PatternVariable nodeId range nodeChild0 ->
        showString "PatternVariable " . showsPrec 11 nodeId . showChar ' ' . showsPrec 11 range . showChar ' ' . showsPrec 11 nodeChild0
      PatternConstructor nodeId range nodeChild0 ->
        showString "PatternConstructor " . showsPrec 11 nodeId . showChar ' ' . showsPrec 11 range . showChar ' ' . showsPrec 11 nodeChild0
      PatternParentheses nodeId range nodeChild0 ->
        showString "PatternParentheses " . showsPrec 11 nodeId . showChar ' ' . showsPrec 11 range . showChar ' ' . showsPrec 11 nodeChild0
      VariableName nodeId range ->
        showString "VariableName " . showsPrec 11 nodeId . showChar ' ' . showsPrec 11 range
      Error nodeId range nodeChild0 ->
        showString "Error " . showsPrec 11 nodeId . showChar ' ' . showsPrec 11 range . showChar ' ' . showsPrec 11 nodeChild0
      Missing nodeId range ->
        showString "Missing " . showsPrec 11 nodeId . showChar ' ' . showsPrec 11 range
      SortMismatch nodeChild0 ->
        showString "SortMismatch " . showsPrec 11 nodeChild0

--------------------------------------------------------------------------------
-- Symbol Table
--------------------------------------------------------------------------------

newtype SymbolTable = SymbolTable {unSymbolTable :: IntMap SomeSymbolSing}

mkSymbolTable :: TS.Language -> IO SymbolTable
mkSymbolTable language =
  fmap (SymbolTable . IM.fromList) . sequence $
    [ mkEntry "source_file" (SomeRegularSymbolSing SSourceFileSymbol)
    , mkEntry "declaration_type_signature" (SomeRegularSymbolSing SDeclarationTypeSignatureSymbol)
    , mkEntry "declaration_function" (SomeRegularSymbolSing SDeclarationFunctionSymbol)
    , mkEntry "expression_variable" (SomeRegularSymbolSing SExpressionVariableSymbol)
    , mkEntry "expression_constructor" (SomeRegularSymbolSing SExpressionConstructorSymbol)
    , mkEntry "expression_function_type" (SomeRegularSymbolSing SExpressionFunctionTypeSymbol)
    , mkEntry "expression_function_application" (SomeRegularSymbolSing SExpressionFunctionApplicationSymbol)
    , mkEntry "expression_function_abstraction" (SomeRegularSymbolSing SExpressionFunctionAbstractionSymbol)
    , mkEntry "expression_annotation" (SomeRegularSymbolSing SExpressionAnnotationSymbol)
    , mkEntry "expression_parentheses" (SomeRegularSymbolSing SExpressionParenthesesSymbol)
    , mkEntry "constructor_name" (SomeRegularSymbolSing SConstructorNameSymbol)
    , mkEntry "pattern_list" (SomeRegularSymbolSing SPatternListSymbol)
    , mkEntry "pattern_variable" (SomeRegularSymbolSing SPatternVariableSymbol)
    , mkEntry "pattern_constructor" (SomeRegularSymbolSing SPatternConstructorSymbol)
    , mkEntry "pattern_parentheses" (SomeRegularSymbolSing SPatternParenthesesSymbol)
    , mkEntry "variable_name" (SomeRegularSymbolSing SVariableNameSymbol)
    ]
 where
  mkEntry :: String -> SomeSymbolSing -> IO (Int, SomeSymbolSing)
  mkEntry grammarType someSymbol = do
    (,someSymbol) . fromIntegral <$> TS.languageSymbolForGrammarType language (BSC.pack grammarType) True

--------------------------------------------------------------------------------
-- Node Cache
--------------------------------------------------------------------------------

newtype AstCache = AstCache {unAstCache :: IntMap SomeNode}
  deriving (Show, Semigroup, Monoid)

--------------------------------------------------------------------------------
-- Parser Monad
--------------------------------------------------------------------------------

data PState = PState
  { currentNode :: {-# UNPACK #-} !TS.Node
  , newCache :: {-# NOUNPACK #-} !AstCache
  }

data PEnv = PEnv
  { symbolTable :: {-# UNPACK #-} !SymbolTable
  , treeCursor :: {-# UNPACK #-} !TS.TreeCursor
  , oldCache :: {-# UNPACK #-} !AstCache
  }

newtype P a = P {unP :: MaybeT (ReaderT PEnv (StateT PState IO)) a}
  deriving (Functor, Applicative, Monad, MonadIO, MonadReader PEnv, MonadState PState, Alternative, MonadPlus)

getCurrentNode :: P TS.Node
getCurrentNode = gets currentNode

putCurrentNode :: TS.Node -> P ()
putCurrentNode node = modify' (\pstate -> pstate{currentNode = node})

getSymbol :: TS.Node -> P SomeSymbolSing
getSymbol node = do
  currentNodeIsError <- liftIO (TS.nodeIsError node)
  if currentNodeIsError
    then pure (SomeAuxiliarySymbolSing SErrorSymbol)
    else do
      currentNodeIsMissing <- liftIO (TS.nodeIsMissing node)
      if currentNodeIsMissing
        then pure (SomeAuxiliarySymbolSing SMissingSymbol)
        else do
          symbol <- liftIO (TS.nodeSymbol node)
          asks ((IM.! fromIntegral symbol) . unSymbolTable . symbolTable)

cacheSomeNode :: SomeNode -> P SomeNode
cacheSomeNode someNode = modify' updatePState >> pure someNode
 where
  nodeId = someNodeToNodeId someNode
  updateAstCache = AstCache . IM.insert (unWrapTSNodeId nodeId) someNode . unAstCache
  updatePState pstate = pstate{newCache = updateAstCache (newCache pstate)}

findOldSomeNodeInCache :: P SomeNode
findOldSomeNodeInCache =
  gets (TS.nodeId . currentNode) >>= \nodeId -> do
    asks (IM.lookup (unWrapTSNodeId nodeId) . unAstCache . oldCache)
      >>= maybe mzero pure

gotoParent :: P ()
gotoParent = do
  treeCursor <- asks treeCursor
  success <- liftIO (TS.treeCursorGotoParent treeCursor)
  if not success
    then mzero
    else do
      currentNode <- liftIO (TS.treeCursorCurrentNode treeCursor)
      putCurrentNode currentNode

gotoFirstNamedChild :: P ()
gotoFirstNamedChild = do
  treeCursor <- asks treeCursor
  success <- liftIO (TS.treeCursorGotoFirstChild treeCursor)
  if not success
    then mzero
    else do
      currentNode <- liftIO (TS.treeCursorCurrentNode treeCursor)
      currentNodeIsNamed <- liftIO (TS.nodeIsNamed currentNode)
      if currentNodeIsNamed
        then putCurrentNode currentNode
        else gotoNextNamedSibling

gotoNextNamedSibling :: P ()
gotoNextNamedSibling = do
  treeCursor <- asks treeCursor
  success <- liftIO (TS.treeCursorGotoNextSibling treeCursor)
  if not success
    then mzero
    else do
      currentNode <- liftIO (TS.treeCursorCurrentNode treeCursor)
      currentNodeIsNamed <- liftIO (TS.nodeIsNamed currentNode)
      if currentNodeIsNamed
        then putCurrentNode currentNode
        else gotoNextNamedSibling

--------------------------------------------------------------------------------
-- Parser Class
--------------------------------------------------------------------------------

class HasParser a where
  p :: P a

instance HasParser NodeId where
  p :: P NodeId
  p = TS.nodeId <$> getCurrentNode

instance HasParser (ChildList '[]) where
  p :: P (ChildList '[])
  p = pure Nil

instance (HasParser a) => HasParser (ChildList (a ': '[])) where
  p :: P (ChildList '[a])
  p = Cons <$> p <*> pure Nil

instance (HasParser a, HasParser (ChildList (b ': bs))) => HasParser (ChildList (a ': b ': bs)) where
  p :: P (ChildList (a ': b ': bs))
  p = Cons <$> p <* gotoNextNamedSibling <*> p

instance (HasParser (ChildList as)) => HasParser (Children as) where
  p :: P (Children as)
  p = Children <$> (gotoFirstNamedChild *> p <* gotoParent)

instance (HasParser a) => HasParser (Maybe a) where
  p :: P (Maybe a)
  p = optional p

instance (HasParser a) => HasParser [a] where
  p :: P [a]
  p = pPostFence p gotoNextNamedSibling

instance (HasParser a) => HasParser (NonEmpty a) where
  p :: P (NonEmpty a)
  p = pPostFence1 p gotoNextNamedSibling

instance HasParser Range where
  p :: P Range
  p = liftIO . TS.nodeRange =<< getCurrentNode

pPostFence :: P a -> P () -> P [a]
pPostFence post fence = postFence
 where
  fencePost = fence *> postFence <|> pure []
  postFence = ((:) <$> post <*> fencePost) <|> pure []

pPostFence1 :: P a -> P () -> P (NonEmpty a)
pPostFence1 post fence = postFence
 where
  fencePost = fence *> pPostFence post fence <|> pure []
  postFence = (:|) <$> post <*> fencePost

--------------------------------------------------------------------------------
-- Node Parser
--------------------------------------------------------------------------------

instance (KnownSort sort) => HasParser (Node sort) where
  p :: P (Node sort)
  p = pNode

pNode :: (KnownSort sort) => P (Node sort)
pNode =
  pSomeNode >>= \someNode@(SomeNode isReal content) -> do
    let symbol = nodeContentToSymbol content
    case isReal of
      RegularIsReal ->
        pure $
          case decSortSing (symbolToSort symbol) sortSing of
            Just prf -> Node (RegularWellSorted prf) content
            Nothing -> SortMismatch someNode
      AuxiliaryIsReal -> pure $ Node AuxiliaryWellSorted content

instance HasParser SomeNode where
  p :: P SomeNode
  p = pSomeNode

pSomeNode :: P SomeNode
pSomeNode = cacheSomeNode =<< pSomeNode' =<< getCurrentNode
 where
  pSomeNode' :: TS.Node -> P SomeNode
  pSomeNode' node = tryCache <|> tryParse
   where
    tryCache = do
      liftIO (TS.nodeHasChanges node) >>= \nodeHasChanges ->
        if nodeHasChanges then mzero else findOldSomeNodeInCache
    tryParse = do
      getSymbol node >>= \(SomeSymbolSing isReal symbol) ->
        SomeNode isReal <$> pNodeContent symbol

pNodeContent :: SymbolSing symbolType symbol -> P (NodeContent symbolType symbol)
pNodeContent = \case
  SSourceFileSymbol -> SourceFileContent <$> p <*> p <*> p
  SDeclarationTypeSignatureSymbol -> DeclarationTypeSignatureContent <$> p <*> p <*> p
  SDeclarationFunctionSymbol -> DeclarationFunctionContent <$> p <*> p <*> p
  SExpressionVariableSymbol -> ExpressionVariableContent <$> p <*> p <*> p
  SExpressionConstructorSymbol -> ExpressionConstructorContent <$> p <*> p <*> p
  SExpressionFunctionTypeSymbol -> ExpressionFunctionTypeContent <$> p <*> p <*> p
  SExpressionFunctionApplicationSymbol -> ExpressionFunctionApplicationContent <$> p <*> p <*> p
  SExpressionFunctionAbstractionSymbol -> ExpressionFunctionAbstractionContent <$> p <*> p <*> p
  SExpressionAnnotationSymbol -> ExpressionAnnotationContent <$> p <*> p <*> p
  SExpressionParenthesesSymbol -> ExpressionParenthesesContent <$> p <*> p <*> p
  SConstructorNameSymbol -> ConstructorNameContent <$> p <*> p
  SPatternListSymbol -> PatternListContent <$> p <*> p <*> p
  SPatternVariableSymbol -> PatternVariableContent <$> p <*> p <*> p
  SPatternConstructorSymbol -> PatternConstructorContent <$> p <*> p <*> p
  SPatternParenthesesSymbol -> PatternParenthesesContent <$> p <*> p <*> p
  SVariableNameSymbol -> VariableNameContent <$> p <*> p
  SErrorSymbol -> ErrorContent <$> p <*> p <*> p
  SMissingSymbol -> MissingContent <$> p <*> p
  SSortMismatchSymbol -> SortMismatchContent <$> p

--------------------------------------------------------------------------------
-- Pretty Printing
--------------------------------------------------------------------------------

instance Pretty SomeNode where
  pretty :: SomeNode -> Doc ann
  pretty (SomeNode _isReal content) = pretty content

instance Pretty (Node sort) where
  pretty :: Node sort -> Doc ann
  pretty (Node _isWellSorted content) = pretty content

instance Pretty (NodeContent symbolType symbol) where
  pretty :: NodeContent symbolType symbol -> Doc ann
  pretty content = prettySList (pretty (nodeContentToSymbol content) : fmap pretty (getNodes content))

prettySList :: [Doc ann] -> Doc ann
prettySList = parens . nest 2 . sep

instance Pretty (SymbolSing symbolType symbol) where
  pretty :: SymbolSing symbolType symbol -> Doc ann
  pretty = \case
    SSourceFileSymbol -> "source_file"
    SDeclarationTypeSignatureSymbol -> "declaration_type_signature"
    SDeclarationFunctionSymbol -> "declaration_function"
    SExpressionVariableSymbol -> "expression_variable"
    SExpressionConstructorSymbol -> "expression_constructor"
    SExpressionFunctionTypeSymbol -> "expression_function_type"
    SExpressionFunctionApplicationSymbol -> "expression_function_application"
    SExpressionFunctionAbstractionSymbol -> "expression_function_abstraction"
    SExpressionAnnotationSymbol -> "expression_annotation"
    SExpressionParenthesesSymbol -> "expression_parentheses"
    SConstructorNameSymbol -> "constructor_name"
    SPatternListSymbol -> "pattern_list"
    SPatternVariableSymbol -> "pattern_variable"
    SPatternConstructorSymbol -> "pattern_constructor"
    SPatternParenthesesSymbol -> "pattern_parentheses"
    SVariableNameSymbol -> "variable_name"
    SErrorSymbol -> "ERROR"
    SMissingSymbol -> "MISSING"
    SSortMismatchSymbol -> "SORT_MISMATCH"
