-- WARNING: This module was generated by `tree-sitter-generate-ast`.
--
--   build-depends:
--     , base          >=4.13 && <5
--     , bytestring    >=0.12 && <0.13
--     , containers    >=0.6  && <0.8
--     , mtl           >=2.3  && <2.4
--     , transformers  >=0.6  && <0.7
--     , tree-sitter
--
{-# LANGUAGE DataKinds #-}
{-# LANGUAGE ImportQualifiedPost #-}
{-# LANGUAGE LambdaCase #-}
{-# LANGUAGE PatternSynonyms #-}
{-# LANGUAGE StandaloneKindSignatures #-}
{-# LANGUAGE TypeData #-}
{-# LANGUAGE TypeFamilies #-}
{-# LANGUAGE UndecidableInstances #-}

module Gilear.Internal.Parser.Ast (
  Sort (..),
  SortSing (..),
  SymbolType (..),
  SymbolTypeSing (..),
  Symbol (..),
  SymbolSing (..),
  SomeSymbolSing (..),
  SymbolTable,
  type (:<) (..),
  Node (
    SourceFile,
    DeclarationTypeSignature,
    DeclarationFunction,
    ExpressionVariable,
    ExpressionConstructor,
    ExpressionFunctionType,
    ExpressionFunctionApplication,
    ExpressionFunctionAbstraction,
    ExpressionAnnotation,
    ExpressionParentheses,
    ConstructorName,
    PatternList,
    PatternVariable,
    PatternConstructor,
    PatternParentheses,
    VariableName,
    Error,
    Missing,
    SortMismatch
  ),
  NodeContent (..),
  Children (..),
  ChildList (..),
  SomeNode (..),
  SomeNodeCache,
  mkSymbolTable,
  nodeContentToSymbol,
  parseTree,
  symbolToSymbolType,
  symbolToSort,
) where

import Control.Applicative (Alternative (..), optional)
import Control.Monad (MonadPlus (..))
import Control.Monad.IO.Class (MonadIO (..))
import Control.Monad.Reader (MonadReader, ReaderT (..), asks)
import Control.Monad.State.Strict (MonadState (..), StateT (..), gets, modify')
import Control.Monad.Trans.Maybe (MaybeT (..))
import Data.ByteString.Char8 qualified as BSC
import Data.IntMap.Strict (IntMap)
import Data.IntMap.Strict qualified as IM
import Data.Kind (Type)
import Data.List.NonEmpty (NonEmpty (..))
import Data.Type.Equality (type (:~:) (..))
import TreeSitter (NodeId (..), Range (..))
import TreeSitter qualified as TS

--------------------------------------------------------------------------------
-- Entry point
--------------------------------------------------------------------------------

parseTree :: SymbolTable -> TS.Tree -> IO (Maybe (Node SourceFileSort, SomeNodeCache))
parseTree symbolTable tree = do
  rootNode <- TS.treeRootNode tree
  treeCursor <- TS.treeCursorNew rootNode
  let pEnv = PEnv symbolTable treeCursor mempty
  let pState = PState rootNode mempty
  (maybeNode, pState') <- runStateT (runMaybeT (runReaderT (unP p) pEnv)) pState
  pure $ fmap (,newCache pState') maybeNode

--------------------------------------------------------------------------------
-- Sort
--------------------------------------------------------------------------------

type data Sort where
  SourceFileSort :: Sort
  DeclarationSort :: Sort
  ExpressionSort :: Sort
  ConstructorNameSort :: Sort
  PatternListSort :: Sort
  PatternSort :: Sort
  VariableNameSort :: Sort

data SortSing (sort :: Sort) where
  SSourceFileSort :: SortSing SourceFileSort
  SDeclarationSort :: SortSing DeclarationSort
  SExpressionSort :: SortSing ExpressionSort
  SConstructorNameSort :: SortSing ConstructorNameSort
  SPatternListSort :: SortSing PatternListSort
  SPatternSort :: SortSing PatternSort
  SVariableNameSort :: SortSing VariableNameSort

deriving instance Show (SortSing sort)

decSortSing :: SortSing sort1 -> SortSing sort2 -> Maybe (sort1 :~: sort2)
decSortSing SSourceFileSort SSourceFileSort = Just Refl
decSortSing SDeclarationSort SDeclarationSort = Just Refl
decSortSing SExpressionSort SExpressionSort = Just Refl
decSortSing SConstructorNameSort SConstructorNameSort = Just Refl
decSortSing SPatternListSort SPatternListSort = Just Refl
decSortSing SPatternSort SPatternSort = Just Refl
decSortSing SVariableNameSort SVariableNameSort = Just Refl
decSortSing _ _ = Nothing

class KnownSort sort where
  sortSing :: SortSing sort

instance KnownSort SourceFileSort where
  sortSing = SSourceFileSort

instance KnownSort DeclarationSort where
  sortSing = SDeclarationSort

instance KnownSort ExpressionSort where
  sortSing = SExpressionSort

instance KnownSort ConstructorNameSort where
  sortSing = SConstructorNameSort

instance KnownSort PatternListSort where
  sortSing = SPatternListSort

instance KnownSort PatternSort where
  sortSing = SPatternSort

instance KnownSort VariableNameSort where
  sortSing = SVariableNameSort

--------------------------------------------------------------------------------
-- SymbolType
--------------------------------------------------------------------------------

type data SymbolType where
  Regular :: SymbolType
  Auxiliary :: SymbolType

data SymbolTypeSing (symbolType :: SymbolType) where
  SRegular :: SymbolTypeSing Regular
  SAuxiliary :: SymbolTypeSing Auxiliary

--------------------------------------------------------------------------------
-- Symbol
--------------------------------------------------------------------------------

type data Symbol (symbolType :: SymbolType) where
  SourceFileSymbol :: (symbolType ~ Regular) => Symbol symbolType
  DeclarationTypeSignatureSymbol :: (symbolType ~ Regular) => Symbol symbolType
  DeclarationFunctionSymbol :: (symbolType ~ Regular) => Symbol symbolType
  ExpressionVariableSymbol :: (symbolType ~ Regular) => Symbol symbolType
  ExpressionConstructorSymbol :: (symbolType ~ Regular) => Symbol symbolType
  ExpressionFunctionTypeSymbol :: (symbolType ~ Regular) => Symbol symbolType
  ExpressionFunctionApplicationSymbol :: (symbolType ~ Regular) => Symbol symbolType
  ExpressionFunctionAbstractionSymbol :: (symbolType ~ Regular) => Symbol symbolType
  ExpressionAnnotationSymbol :: (symbolType ~ Regular) => Symbol symbolType
  ExpressionParenthesesSymbol :: (symbolType ~ Regular) => Symbol symbolType
  ConstructorNameSymbol :: (symbolType ~ Regular) => Symbol symbolType
  PatternListSymbol :: (symbolType ~ Regular) => Symbol symbolType
  PatternVariableSymbol :: (symbolType ~ Regular) => Symbol symbolType
  PatternConstructorSymbol :: (symbolType ~ Regular) => Symbol symbolType
  PatternParenthesesSymbol :: (symbolType ~ Regular) => Symbol symbolType
  VariableNameSymbol :: (symbolType ~ Regular) => Symbol symbolType
  ErrorSymbol :: (symbolType ~ Auxiliary) => Symbol symbolType
  MissingSymbol :: (symbolType ~ Auxiliary) => Symbol symbolType
  SortMismatchSymbol :: (symbolType ~ Auxiliary) => Symbol symbolType

data SymbolSing (symbolType :: SymbolType) (symbol :: Symbol symbolType) where
  SSourceFileSymbol :: SymbolSing Regular SourceFileSymbol
  SDeclarationTypeSignatureSymbol :: SymbolSing Regular DeclarationTypeSignatureSymbol
  SDeclarationFunctionSymbol :: SymbolSing Regular DeclarationFunctionSymbol
  SExpressionVariableSymbol :: SymbolSing Regular ExpressionVariableSymbol
  SExpressionConstructorSymbol :: SymbolSing Regular ExpressionConstructorSymbol
  SExpressionFunctionTypeSymbol :: SymbolSing Regular ExpressionFunctionTypeSymbol
  SExpressionFunctionApplicationSymbol :: SymbolSing Regular ExpressionFunctionApplicationSymbol
  SExpressionFunctionAbstractionSymbol :: SymbolSing Regular ExpressionFunctionAbstractionSymbol
  SExpressionAnnotationSymbol :: SymbolSing Regular ExpressionAnnotationSymbol
  SExpressionParenthesesSymbol :: SymbolSing Regular ExpressionParenthesesSymbol
  SConstructorNameSymbol :: SymbolSing Regular ConstructorNameSymbol
  SPatternListSymbol :: SymbolSing Regular PatternListSymbol
  SPatternVariableSymbol :: SymbolSing Regular PatternVariableSymbol
  SPatternConstructorSymbol :: SymbolSing Regular PatternConstructorSymbol
  SPatternParenthesesSymbol :: SymbolSing Regular PatternParenthesesSymbol
  SVariableNameSymbol :: SymbolSing Regular VariableNameSymbol
  SErrorSymbol :: SymbolSing Auxiliary ErrorSymbol
  SMissingSymbol :: SymbolSing Auxiliary MissingSymbol
  SSortMismatchSymbol :: SymbolSing Auxiliary SortMismatchSymbol

deriving instance Show (SymbolSing sort symbol)

data SomeSymbolSing
  = forall (symbolType :: SymbolType) (symbol :: Symbol symbolType).
    SomeSymbolSing !(SymbolSing symbolType symbol)

deriving instance Show SomeSymbolSing

--------------------------------------------------------------------------------
-- Getting the symbol types for symbols
--------------------------------------------------------------------------------

symbolToSymbolType :: SymbolSing symbolType symbol -> SymbolTypeSing symbolType
symbolToSymbolType = \case
  SSourceFileSymbol -> SRegular
  SDeclarationTypeSignatureSymbol -> SRegular
  SDeclarationFunctionSymbol -> SRegular
  SExpressionVariableSymbol -> SRegular
  SExpressionConstructorSymbol -> SRegular
  SExpressionFunctionTypeSymbol -> SRegular
  SExpressionFunctionApplicationSymbol -> SRegular
  SExpressionFunctionAbstractionSymbol -> SRegular
  SExpressionAnnotationSymbol -> SRegular
  SExpressionParenthesesSymbol -> SRegular
  SConstructorNameSymbol -> SRegular
  SPatternListSymbol -> SRegular
  SPatternVariableSymbol -> SRegular
  SPatternConstructorSymbol -> SRegular
  SPatternParenthesesSymbol -> SRegular
  SVariableNameSymbol -> SRegular
  SErrorSymbol -> SAuxiliary
  SMissingSymbol -> SAuxiliary
  SSortMismatchSymbol -> SAuxiliary

--------------------------------------------------------------------------------
-- Inferring sorts for regular symbols
--------------------------------------------------------------------------------

type family SymbolSort (symbol :: Symbol Regular) :: Sort where
  SymbolSort SourceFileSymbol = SourceFileSort
  SymbolSort DeclarationTypeSignatureSymbol = DeclarationSort
  SymbolSort DeclarationFunctionSymbol = DeclarationSort
  SymbolSort ExpressionVariableSymbol = ExpressionSort
  SymbolSort ExpressionConstructorSymbol = ExpressionSort
  SymbolSort ExpressionFunctionTypeSymbol = ExpressionSort
  SymbolSort ExpressionFunctionApplicationSymbol = ExpressionSort
  SymbolSort ExpressionFunctionAbstractionSymbol = ExpressionSort
  SymbolSort ExpressionAnnotationSymbol = ExpressionSort
  SymbolSort ExpressionParenthesesSymbol = ExpressionSort
  SymbolSort ConstructorNameSymbol = ConstructorNameSort
  SymbolSort PatternListSymbol = PatternListSort
  SymbolSort PatternVariableSymbol = PatternSort
  SymbolSort PatternConstructorSymbol = PatternSort
  SymbolSort PatternParenthesesSymbol = PatternSort
  SymbolSort VariableNameSymbol = VariableNameSort

symbolToSort :: SymbolSing Regular symbol -> SortSing (SymbolSort symbol)
symbolToSort = \case
  SSourceFileSymbol -> SSourceFileSort
  SDeclarationTypeSignatureSymbol -> SDeclarationSort
  SDeclarationFunctionSymbol -> SDeclarationSort
  SExpressionVariableSymbol -> SExpressionSort
  SExpressionConstructorSymbol -> SExpressionSort
  SExpressionFunctionTypeSymbol -> SExpressionSort
  SExpressionFunctionApplicationSymbol -> SExpressionSort
  SExpressionFunctionAbstractionSymbol -> SExpressionSort
  SExpressionAnnotationSymbol -> SExpressionSort
  SExpressionParenthesesSymbol -> SExpressionSort
  SConstructorNameSymbol -> SConstructorNameSort
  SPatternListSymbol -> SPatternListSort
  SPatternVariableSymbol -> SPatternSort
  SPatternConstructorSymbol -> SPatternSort
  SPatternParenthesesSymbol -> SPatternSort
  SVariableNameSymbol -> SVariableNameSort

--------------------------------------------------------------------------------
-- Well-sortedness for symbols
--------------------------------------------------------------------------------

type (:<) :: forall (symbolType :: SymbolType). Symbol symbolType -> Sort -> Type
data (:<) symbol sort where
  AuxiliaryWellSorted ::
    forall (symbol :: Symbol Auxiliary) (sort :: Sort).
    symbol :< sort
  RegularWellSorted ::
    forall (symbol :: Symbol Regular) (sort :: Sort).
    !(SymbolSort symbol :~: sort) ->
    symbol :< sort

deriving instance Show (symbol :< sort)

--------------------------------------------------------------------------------
-- Nodes
--------------------------------------------------------------------------------

data Node (sort :: Sort)
  = forall (symbolType :: SymbolType) (symbol :: Symbol symbolType).
  Node
  { nodeWellSorted :: !(symbol :< sort)
  , nodeContent :: !(NodeContent symbolType symbol)
  }

deriving instance Show (Node sort)

data SomeNode
  = forall (symbolType :: SymbolType) (symbol :: Symbol symbolType).
  SomeNode
  { someNodeContent :: !(NodeContent symbolType symbol)
  }

deriving instance Show SomeNode

data NodeContent (symbolType :: SymbolType) (symbol :: Symbol symbolType) where
  SourceFileContent ::
    !NodeId ->
    !Range ->
    !(Children '[[Node DeclarationSort]]) ->
    NodeContent Regular SourceFileSymbol
  DeclarationTypeSignatureContent ::
    !NodeId ->
    !Range ->
    !(Children '[Node VariableNameSort, Node ExpressionSort]) ->
    NodeContent Regular DeclarationTypeSignatureSymbol
  DeclarationFunctionContent ::
    !NodeId ->
    !Range ->
    !(Children '[Node VariableNameSort, Maybe (Node PatternListSort), Node ExpressionSort]) ->
    NodeContent Regular DeclarationFunctionSymbol
  ExpressionVariableContent ::
    !NodeId ->
    !Range ->
    !(Children '[Node VariableNameSort]) ->
    NodeContent Regular ExpressionVariableSymbol
  ExpressionConstructorContent ::
    !NodeId ->
    !Range ->
    !(Children '[Node ConstructorNameSort]) ->
    NodeContent Regular ExpressionConstructorSymbol
  ExpressionFunctionTypeContent ::
    !NodeId ->
    !Range ->
    !(Children '[Node ExpressionSort, Node ExpressionSort]) ->
    NodeContent Regular ExpressionFunctionTypeSymbol
  ExpressionFunctionApplicationContent ::
    !NodeId ->
    !Range ->
    !(Children '[Node ExpressionSort, Node ExpressionSort]) ->
    NodeContent Regular ExpressionFunctionApplicationSymbol
  ExpressionFunctionAbstractionContent ::
    !NodeId ->
    !Range ->
    !(Children '[Node PatternListSort, Node ExpressionSort]) ->
    NodeContent Regular ExpressionFunctionAbstractionSymbol
  ExpressionAnnotationContent ::
    !NodeId ->
    !Range ->
    !(Children '[Node ExpressionSort, Node ExpressionSort]) ->
    NodeContent Regular ExpressionAnnotationSymbol
  ExpressionParenthesesContent ::
    !NodeId ->
    !Range ->
    !(Children '[Node ExpressionSort]) ->
    NodeContent Regular ExpressionParenthesesSymbol
  ConstructorNameContent ::
    !NodeId ->
    !Range ->
    NodeContent Regular ConstructorNameSymbol
  PatternListContent ::
    !NodeId ->
    !Range ->
    !(Children '[NonEmpty (Node PatternSort)]) ->
    NodeContent Regular PatternListSymbol
  PatternVariableContent ::
    !NodeId ->
    !Range ->
    !(Children '[Node VariableNameSort]) ->
    NodeContent Regular PatternVariableSymbol
  PatternConstructorContent ::
    !NodeId ->
    !Range ->
    !(Children '[Node ConstructorNameSort]) ->
    NodeContent Regular PatternConstructorSymbol
  PatternParenthesesContent ::
    !NodeId ->
    !Range ->
    !(Children '[Node PatternSort]) ->
    NodeContent Regular PatternParenthesesSymbol
  VariableNameContent ::
    !NodeId ->
    !Range ->
    NodeContent Regular VariableNameSymbol
  ErrorContent ::
    !NodeId ->
    !Range ->
    !(Children '[[SomeNode]]) ->
    NodeContent Auxiliary ErrorSymbol
  MissingContent ::
    !NodeId ->
    !Range ->
    NodeContent Auxiliary MissingSymbol
  SortMismatchContent ::
    !SomeNode ->
    NodeContent Auxiliary SortMismatchSymbol

deriving instance Show (NodeContent symbolType symbol)

nodeContentToSymbol ::
  forall (symbolType :: SymbolType) (symbol :: Symbol symbolType).
  NodeContent symbolType symbol ->
  SymbolSing symbolType symbol
nodeContentToSymbol = \case
  SourceFileContent{} -> SSourceFileSymbol
  DeclarationTypeSignatureContent{} -> SDeclarationTypeSignatureSymbol
  DeclarationFunctionContent{} -> SDeclarationFunctionSymbol
  ExpressionVariableContent{} -> SExpressionVariableSymbol
  ExpressionConstructorContent{} -> SExpressionConstructorSymbol
  ExpressionFunctionTypeContent{} -> SExpressionFunctionTypeSymbol
  ExpressionFunctionApplicationContent{} -> SExpressionFunctionApplicationSymbol
  ExpressionFunctionAbstractionContent{} -> SExpressionFunctionAbstractionSymbol
  ExpressionAnnotationContent{} -> SExpressionAnnotationSymbol
  ExpressionParenthesesContent{} -> SExpressionParenthesesSymbol
  ConstructorNameContent{} -> SConstructorNameSymbol
  PatternListContent{} -> SPatternListSymbol
  PatternVariableContent{} -> SPatternVariableSymbol
  PatternConstructorContent{} -> SPatternConstructorSymbol
  PatternParenthesesContent{} -> SPatternParenthesesSymbol
  VariableNameContent{} -> SVariableNameSymbol
  ErrorContent{} -> SErrorSymbol
  MissingContent{} -> SMissingSymbol
  SortMismatchContent{} -> SSortMismatchSymbol

--------------------------------------------------------------------------------
-- Node Children as Heterogeneous Lists
--------------------------------------------------------------------------------

data ChildList (as :: [Type]) :: Type where
  Nil :: ChildList '[]
  Cons :: !a -> !(ChildList as) -> ChildList (a ': as)

deriving instance Show (ChildList '[])

deriving instance (Show a, Show (ChildList as)) => Show (ChildList (a ': as))

newtype Children as = Children (ChildList as)

deriving instance (Show (ChildList as)) => Show (Children as)

--------------------------------------------------------------------------------
-- Pattern Synonyms
--------------------------------------------------------------------------------

pattern SourceFile :: NodeId -> Range -> [Node DeclarationSort] -> Node SourceFileSort
pattern SourceFile nodeId nodeRange nodeChild0 =
  Node (RegularWellSorted Refl) (SourceFileContent nodeId nodeRange (Children (Cons nodeChild0 Nil)))

pattern DeclarationTypeSignature :: NodeId -> Range -> Node VariableNameSort -> Node ExpressionSort -> Node DeclarationSort
pattern DeclarationTypeSignature nodeId nodeRange nodeChild0 nodeChild1 =
  Node (RegularWellSorted Refl) (DeclarationTypeSignatureContent nodeId nodeRange (Children (Cons nodeChild0 (Cons nodeChild1 Nil))))

pattern DeclarationFunction :: NodeId -> Range -> Node VariableNameSort -> Maybe (Node PatternListSort) -> Node ExpressionSort -> Node DeclarationSort
pattern DeclarationFunction nodeId nodeRange nodeChild0 nodeChild1 nodeChild2 =
  Node (RegularWellSorted Refl) (DeclarationFunctionContent nodeId nodeRange (Children (Cons nodeChild0 (Cons nodeChild1 (Cons nodeChild2 Nil)))))

pattern ExpressionVariable :: NodeId -> Range -> Node VariableNameSort -> Node ExpressionSort
pattern ExpressionVariable nodeId nodeRange nodeChild0 =
  Node (RegularWellSorted Refl) (ExpressionVariableContent nodeId nodeRange (Children (Cons nodeChild0 Nil)))

pattern ExpressionConstructor :: NodeId -> Range -> Node ConstructorNameSort -> Node ExpressionSort
pattern ExpressionConstructor nodeId nodeRange nodeChild0 =
  Node (RegularWellSorted Refl) (ExpressionConstructorContent nodeId nodeRange (Children (Cons nodeChild0 Nil)))

pattern ExpressionFunctionType :: NodeId -> Range -> Node ExpressionSort -> Node ExpressionSort -> Node ExpressionSort
pattern ExpressionFunctionType nodeId nodeRange nodeChild0 nodeChild1 =
  Node (RegularWellSorted Refl) (ExpressionFunctionTypeContent nodeId nodeRange (Children (Cons nodeChild0 (Cons nodeChild1 Nil))))

pattern ExpressionFunctionApplication :: NodeId -> Range -> Node ExpressionSort -> Node ExpressionSort -> Node ExpressionSort
pattern ExpressionFunctionApplication nodeId nodeRange nodeChild0 nodeChild1 =
  Node (RegularWellSorted Refl) (ExpressionFunctionApplicationContent nodeId nodeRange (Children (Cons nodeChild0 (Cons nodeChild1 Nil))))

pattern ExpressionFunctionAbstraction :: NodeId -> Range -> Node PatternListSort -> Node ExpressionSort -> Node ExpressionSort
pattern ExpressionFunctionAbstraction nodeId nodeRange nodeChild0 nodeChild1 =
  Node (RegularWellSorted Refl) (ExpressionFunctionAbstractionContent nodeId nodeRange (Children (Cons nodeChild0 (Cons nodeChild1 Nil))))

pattern ExpressionAnnotation :: NodeId -> Range -> Node ExpressionSort -> Node ExpressionSort -> Node ExpressionSort
pattern ExpressionAnnotation nodeId nodeRange nodeChild0 nodeChild1 =
  Node (RegularWellSorted Refl) (ExpressionAnnotationContent nodeId nodeRange (Children (Cons nodeChild0 (Cons nodeChild1 Nil))))

pattern ExpressionParentheses :: NodeId -> Range -> Node ExpressionSort -> Node ExpressionSort
pattern ExpressionParentheses nodeId nodeRange nodeChild0 =
  Node (RegularWellSorted Refl) (ExpressionParenthesesContent nodeId nodeRange (Children (Cons nodeChild0 Nil)))

pattern ConstructorName :: NodeId -> Range -> Node ConstructorNameSort
pattern ConstructorName nodeId nodeRange =
  Node (RegularWellSorted Refl) (ConstructorNameContent nodeId nodeRange)

pattern PatternList :: NodeId -> Range -> NonEmpty (Node PatternSort) -> Node PatternListSort
pattern PatternList nodeId nodeRange nodeChild0 =
  Node (RegularWellSorted Refl) (PatternListContent nodeId nodeRange (Children (Cons nodeChild0 Nil)))

pattern PatternVariable :: NodeId -> Range -> Node VariableNameSort -> Node PatternSort
pattern PatternVariable nodeId nodeRange nodeChild0 =
  Node (RegularWellSorted Refl) (PatternVariableContent nodeId nodeRange (Children (Cons nodeChild0 Nil)))

pattern PatternConstructor :: NodeId -> Range -> Node ConstructorNameSort -> Node PatternSort
pattern PatternConstructor nodeId nodeRange nodeChild0 =
  Node (RegularWellSorted Refl) (PatternConstructorContent nodeId nodeRange (Children (Cons nodeChild0 Nil)))

pattern PatternParentheses :: NodeId -> Range -> Node PatternSort -> Node PatternSort
pattern PatternParentheses nodeId nodeRange nodeChild0 =
  Node (RegularWellSorted Refl) (PatternParenthesesContent nodeId nodeRange (Children (Cons nodeChild0 Nil)))

pattern VariableName :: NodeId -> Range -> Node VariableNameSort
pattern VariableName nodeId nodeRange =
  Node (RegularWellSorted Refl) (VariableNameContent nodeId nodeRange)

pattern Error :: NodeId -> Range -> [SomeNode] -> Node sort
pattern Error nodeId nodeRange nodeChild0 =
  Node AuxiliaryWellSorted (ErrorContent nodeId nodeRange (Children (Cons nodeChild0 Nil)))

pattern Missing :: NodeId -> Range -> Node sort
pattern Missing nodeId nodeRange =
  Node AuxiliaryWellSorted (MissingContent nodeId nodeRange)

pattern SortMismatch :: SomeNode -> Node sort
pattern SortMismatch nodeChild0 =
  Node AuxiliaryWellSorted (SortMismatchContent nodeChild0)

{-# COMPLETE
  SourceFile
  , DeclarationTypeSignature
  , DeclarationFunction
  , ExpressionVariable
  , ExpressionConstructor
  , ExpressionFunctionType
  , ExpressionFunctionApplication
  , ExpressionFunctionAbstraction
  , ExpressionAnnotation
  , ExpressionParentheses
  , ConstructorName
  , PatternList
  , PatternVariable
  , PatternConstructor
  , PatternParentheses
  , VariableName
  , Error
  , Missing
  , SortMismatch
  #-}

--------------------------------------------------------------------------------
-- Symbol Table
--------------------------------------------------------------------------------

newtype SymbolTable = SymbolTable {unSymbolTable :: IntMap SomeSymbolSing}

mkSymbolTable :: TS.Language -> IO SymbolTable
mkSymbolTable language =
  fmap (SymbolTable . IM.fromList) . sequence $
    [ mkEntry "source_file" (SomeSymbolSing SSourceFileSymbol)
    , mkEntry "declaration_type_signature" (SomeSymbolSing SDeclarationTypeSignatureSymbol)
    , mkEntry "declaration_function" (SomeSymbolSing SDeclarationFunctionSymbol)
    , mkEntry "expression_variable" (SomeSymbolSing SExpressionVariableSymbol)
    , mkEntry "expression_constructor" (SomeSymbolSing SExpressionConstructorSymbol)
    , mkEntry "expression_function_type" (SomeSymbolSing SExpressionFunctionTypeSymbol)
    , mkEntry "expression_function_application" (SomeSymbolSing SExpressionFunctionApplicationSymbol)
    , mkEntry "expression_function_abstraction" (SomeSymbolSing SExpressionFunctionAbstractionSymbol)
    , mkEntry "expression_annotation" (SomeSymbolSing SExpressionAnnotationSymbol)
    , mkEntry "expression_parentheses" (SomeSymbolSing SExpressionParenthesesSymbol)
    , mkEntry "constructor_name" (SomeSymbolSing SConstructorNameSymbol)
    , mkEntry "pattern_list" (SomeSymbolSing SPatternListSymbol)
    , mkEntry "pattern_variable" (SomeSymbolSing SPatternVariableSymbol)
    , mkEntry "pattern_constructor" (SomeSymbolSing SPatternConstructorSymbol)
    , mkEntry "pattern_parentheses" (SomeSymbolSing SPatternParenthesesSymbol)
    , mkEntry "variable_name" (SomeSymbolSing SVariableNameSymbol)
    ]
 where
  mkEntry :: String -> SomeSymbolSing -> IO (Int, SomeSymbolSing)
  mkEntry grammarType someSymbol = do
    (,someSymbol) . fromIntegral <$> TS.languageSymbolForGrammarType language (BSC.pack grammarType) True

--------------------------------------------------------------------------------
-- Node Cache
--------------------------------------------------------------------------------

newtype SomeNodeCache = SomeNodeCache {unSomeNodeCache :: IntMap SomeNode}
  deriving (Show, Semigroup, Monoid)

insertSomeNode :: NodeId -> SomeNode -> SomeNodeCache -> SomeNodeCache
insertSomeNode nodeId someNode someNodeCacheMap =
  SomeNodeCache (IM.insert (unWrapTSNodeId nodeId) someNode (unSomeNodeCache someNodeCacheMap))

--------------------------------------------------------------------------------
-- Parser Monad
--------------------------------------------------------------------------------

data PState = PState
  { currentNode :: TS.Node
  , newCache :: !SomeNodeCache
  }

data PEnv = PEnv
  { symbolTable :: !SymbolTable
  , treeCursor :: !TS.TreeCursor
  , oldCache :: !SomeNodeCache
  }

newtype P a = P {unP :: ReaderT PEnv (MaybeT (StateT PState IO)) a}
  deriving (Functor, Applicative, Monad, MonadIO, MonadReader PEnv, MonadState PState, Alternative, MonadPlus)

getCurrentNode :: P TS.Node
getCurrentNode = gets currentNode

putCurrentNode :: TS.Node -> P ()
putCurrentNode node = modify' (\pstate -> pstate{currentNode = node})

getSymbol :: TS.Node -> P SomeSymbolSing
getSymbol node = do
  currentNodeIsError <- liftIO (TS.nodeIsError node)
  if currentNodeIsError
    then pure (SomeSymbolSing SErrorSymbol)
    else do
      currentNodeIsMissing <- liftIO (TS.nodeIsMissing node)
      if currentNodeIsMissing
        then pure (SomeSymbolSing SMissingSymbol)
        else do
          symbol <- liftIO (TS.nodeSymbol node)
          asks ((IM.! fromIntegral symbol) . unSymbolTable . symbolTable)

emitSomeNode :: NodeId -> SomeNode -> P SomeNode
emitSomeNode nodeId someNode = modify' updatePState >> pure someNode
 where
  updatePState pstate = pstate{newCache = insertSomeNode nodeId someNode (newCache pstate)}

lookupSomeNode :: NodeId -> P SomeNode
lookupSomeNode nodeId =
  maybe mzero pure . IM.lookup (unWrapTSNodeId nodeId) . unSomeNodeCache =<< asks oldCache

gotoParent :: P ()
gotoParent = do
  treeCursor <- asks treeCursor
  success <- liftIO (TS.treeCursorGotoParent treeCursor)
  if not success
    then mzero
    else do
      currentNode <- liftIO (TS.treeCursorCurrentNode treeCursor)
      putCurrentNode currentNode

gotoFirstNamedChild :: P ()
gotoFirstNamedChild = do
  treeCursor <- asks treeCursor
  success <- liftIO (TS.treeCursorGotoFirstChild treeCursor)
  if not success
    then mzero
    else do
      currentNode <- liftIO (TS.treeCursorCurrentNode treeCursor)
      currentNodeIsNamed <- liftIO (TS.nodeIsNamed currentNode)
      if currentNodeIsNamed
        then putCurrentNode currentNode
        else gotoNextNamedSibling

gotoNextNamedSibling :: P ()
gotoNextNamedSibling = do
  treeCursor <- asks treeCursor
  success <- liftIO (TS.treeCursorGotoNextSibling treeCursor)
  if not success
    then mzero
    else do
      currentNode <- liftIO (TS.treeCursorCurrentNode treeCursor)
      currentNodeIsNamed <- liftIO (TS.nodeIsNamed currentNode)
      if currentNodeIsNamed
        then putCurrentNode currentNode
        else gotoNextNamedSibling

--------------------------------------------------------------------------------
-- Parser Class
--------------------------------------------------------------------------------

class HasParser a where
  p :: P a

instance HasParser NodeId where
  p :: P NodeId
  p = TS.nodeId <$> getCurrentNode

instance HasParser (ChildList '[]) where
  p :: P (ChildList '[])
  p = pure Nil

instance (HasParser a) => HasParser (ChildList (a ': '[])) where
  p :: (HasParser a) => P (ChildList '[a])
  p = Cons <$> p <*> pure Nil

instance (HasParser a, HasParser (ChildList (b ': bs))) => HasParser (ChildList (a ': b ': bs)) where
  p :: (HasParser a, HasParser (ChildList (b : bs))) => P (ChildList (a ': b ': bs))
  p = Cons <$> p <* gotoNextNamedSibling <*> p

instance (HasParser (ChildList as)) => HasParser (Children as) where
  p :: (HasParser (ChildList as)) => P (Children as)
  p = Children <$> (gotoFirstNamedChild *> p <* gotoParent)

instance (HasParser a) => HasParser (Maybe a) where
  p :: (HasParser a) => P (Maybe a)
  p = optional p

instance (HasParser a) => HasParser [a] where
  p :: (HasParser a) => P [a]
  p = pPostFence p gotoNextNamedSibling

instance (HasParser a) => HasParser (NonEmpty a) where
  p :: (HasParser a) => P (NonEmpty a)
  p = pPostFence1 p gotoNextNamedSibling

instance HasParser Range where
  p :: P Range
  p = liftIO . TS.nodeRange =<< getCurrentNode

pPostFence :: P a -> P () -> P [a]
pPostFence post fence = postFence
 where
  fencePost = fence *> postFence <|> pure []
  postFence = ((:) <$> post <*> fencePost) <|> pure []

pPostFence1 :: P a -> P () -> P (NonEmpty a)
pPostFence1 post fence = postFence
 where
  fencePost = fence *> pPostFence post fence <|> pure []
  postFence = (:|) <$> post <*> fencePost

--------------------------------------------------------------------------------
-- Node Parser
--------------------------------------------------------------------------------

instance (KnownSort sort) => HasParser (Node sort) where
  p :: (KnownSort sort) => P (Node sort)
  p = pNode

pNode :: (KnownSort sort) => P (Node sort)
pNode =
  pSomeNode >>= \(SomeNode nodeContent) -> do
    let symbol = nodeContentToSymbol nodeContent
    let symbolType = symbolToSymbolType symbol
    case symbolType of
      SRegular ->
        pure $
          case decSortSing (symbolToSort symbol) sortSing of
            Just prf -> Node (RegularWellSorted prf) nodeContent
            Nothing -> SortMismatch (SomeNode nodeContent)
      SAuxiliary -> pure $ Node AuxiliaryWellSorted nodeContent

instance HasParser SomeNode where
  p :: P SomeNode
  p = pSomeNode

pSomeNode :: P SomeNode
pSomeNode = pSomeNode' =<< getCurrentNode
 where
  pSomeNode' :: TS.Node -> P SomeNode
  pSomeNode' node = emitSomeNode nodeId =<< tryCache <|> tryParse
   where
    nodeId = TS.nodeId node
    tryCache = do
      nodeHasChanges <- liftIO (TS.nodeHasChanges node)
      if nodeHasChanges then lookupSomeNode nodeId else mzero
    tryParse = do
      getSymbol node >>= \(SomeSymbolSing symbol) -> do
        -- grammarType <- liftIO (TS.nodeGrammarTypeAsString node)
        -- liftIO (printf "(%s %#x) -> %s\n" grammarType (unWrapTSNodeId nodeId) (show symbol))
        SomeNode <$> pNodeContent symbol

pNodeContent :: SymbolSing symbolType symbol -> P (NodeContent symbolType symbol)
pNodeContent = \case
  SSourceFileSymbol -> SourceFileContent <$> p <*> p <*> p
  SDeclarationTypeSignatureSymbol -> DeclarationTypeSignatureContent <$> p <*> p <*> p
  SDeclarationFunctionSymbol -> DeclarationFunctionContent <$> p <*> p <*> p
  SExpressionVariableSymbol -> ExpressionVariableContent <$> p <*> p <*> p
  SExpressionConstructorSymbol -> ExpressionConstructorContent <$> p <*> p <*> p
  SExpressionFunctionTypeSymbol -> ExpressionFunctionTypeContent <$> p <*> p <*> p
  SExpressionFunctionApplicationSymbol -> ExpressionFunctionApplicationContent <$> p <*> p <*> p
  SExpressionFunctionAbstractionSymbol -> ExpressionFunctionAbstractionContent <$> p <*> p <*> p
  SExpressionAnnotationSymbol -> ExpressionAnnotationContent <$> p <*> p <*> p
  SExpressionParenthesesSymbol -> ExpressionParenthesesContent <$> p <*> p <*> p
  SConstructorNameSymbol -> ConstructorNameContent <$> p <*> p
  SPatternListSymbol -> PatternListContent <$> p <*> p <*> p
  SPatternVariableSymbol -> PatternVariableContent <$> p <*> p <*> p
  SPatternConstructorSymbol -> PatternConstructorContent <$> p <*> p <*> p
  SPatternParenthesesSymbol -> PatternParenthesesContent <$> p <*> p <*> p
  SVariableNameSymbol -> VariableNameContent <$> p <*> p
  SErrorSymbol -> ErrorContent <$> p <*> p <*> p
  SMissingSymbol -> MissingContent <$> p <*> p
  SSortMismatchSymbol -> SortMismatchContent <$> p
