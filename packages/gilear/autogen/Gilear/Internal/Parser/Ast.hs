-- WARNING: This module was generated by `tree-sitter-generate-ast`.
--
-- build-depends:
--   , base          >=4.13 && <5
--   , bytestring    >=0.12 && <0.13
--   , containers    >=0.6  && <0.8
--   , mtl           >=2.3  && <2.4
--   , prettyprinter >=1.7  && <1.8
--   , transformers  >=0.6  && <0.7
--   , tree-sitter
--
{-# LANGUAGE DataKinds #-}
{-# LANGUAGE ImportQualifiedPost #-}
{-# LANGUAGE LambdaCase #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE PatternSynonyms #-}
{-# LANGUAGE StandaloneKindSignatures #-}
{-# LANGUAGE TypeData #-}
{-# LANGUAGE TypeFamilies #-}
{-# LANGUAGE UndecidableInstances #-}

module Gilear.Internal.Parser.Ast (
  Sort (..),
  SortSing (..),
  decSortSing,
  SymbolType (..),
  SymbolTypeSing (..),
  decSymbolTypeSing,
  Symbol (..),
  SymbolSing (..),
  decSymbolSing,
  symbolToSymbolType,
  SymbolToSort,
  symbolToSort,
  SomeSymbolSing (..),
  SymbolTable,
  mkSymbolTable,
  type (:<) (..),
  Node (
    SourceFile,
    DeclarationTypeSignature,
    DeclarationFunction,
    ExpressionVariable,
    ExpressionConstructor,
    ExpressionFunctionType,
    ExpressionFunctionApplication,
    ExpressionFunctionAbstraction,
    ExpressionAnnotation,
    ExpressionParentheses,
    ConstructorName,
    PatternList,
    PatternVariable,
    PatternConstructor,
    PatternParentheses,
    VariableName,
    Error,
    Missing,
    SortMismatch
  ),
  NodeContent (..),
  nodeContentToSymbol,
  Children (..),
  ChildList (..),
  SomeNode (..),
  Ast,
  AstCache,
  parseAst,
) where

import Control.Applicative (Alternative (..), optional)
import Control.Monad (MonadPlus (..))
import Control.Monad.IO.Class (MonadIO (..))
import Control.Monad.Reader (MonadReader, ReaderT (..), asks)
import Control.Monad.State.Strict (MonadState (..), StateT (..), gets, modify')
import Control.Monad.Trans.Maybe (MaybeT (..))
import Data.ByteString.Char8 qualified as BSC
import Data.IntMap.Strict (IntMap)
import Data.IntMap.Strict qualified as IM
import Data.Kind (Type)
import Data.List.NonEmpty (NonEmpty (..))
import Data.Maybe (isJust)
import Data.Type.Equality (type (:~:) (..), type (:~~:) (..))
import Prettyprinter (Pretty (..), line, nest, parens, sep)
import TreeSitter (NodeId (..), Range (..))
import TreeSitter qualified as TS

--------------------------------------------------------------------------------
-- Entry point
--------------------------------------------------------------------------------

type Ast = Node SourceFileSort

parseAst :: SymbolTable -> TS.Tree -> AstCache -> IO (Maybe (Ast, AstCache))
parseAst symbolTable tree astCache = do
  rootNode <- TS.treeRootNode tree
  treeCursor <- TS.treeCursorNew rootNode
  let pEnv = PEnv symbolTable treeCursor astCache
  let pState = PState rootNode mempty
  (maybeNode, pState') <- runStateT (runMaybeT (runReaderT (unP p) pEnv)) pState
  pure $ (,newCache pState') <$> maybeNode

--------------------------------------------------------------------------------
-- Sort
--------------------------------------------------------------------------------

type data Sort where
  SourceFileSort :: Sort
  DeclarationSort :: Sort
  ExpressionSort :: Sort
  ConstructorNameSort :: Sort
  PatternListSort :: Sort
  PatternSort :: Sort
  VariableNameSort :: Sort

data SortSing (sort :: Sort) where
  SSourceFileSort :: SortSing SourceFileSort
  SDeclarationSort :: SortSing DeclarationSort
  SExpressionSort :: SortSing ExpressionSort
  SConstructorNameSort :: SortSing ConstructorNameSort
  SPatternListSort :: SortSing PatternListSort
  SPatternSort :: SortSing PatternSort
  SVariableNameSort :: SortSing VariableNameSort

deriving instance Eq (SortSing sort)

deriving instance Show (SortSing sort)

decSortSing :: SortSing sort1 -> SortSing sort2 -> Maybe (sort1 :~: sort2)
decSortSing SSourceFileSort SSourceFileSort = Just Refl
decSortSing SDeclarationSort SDeclarationSort = Just Refl
decSortSing SExpressionSort SExpressionSort = Just Refl
decSortSing SConstructorNameSort SConstructorNameSort = Just Refl
decSortSing SPatternListSort SPatternListSort = Just Refl
decSortSing SPatternSort SPatternSort = Just Refl
decSortSing SVariableNameSort SVariableNameSort = Just Refl
decSortSing _ _ = Nothing

class KnownSort sort where
  sortSing :: SortSing sort

instance KnownSort SourceFileSort where
  sortSing = SSourceFileSort

instance KnownSort DeclarationSort where
  sortSing = SDeclarationSort

instance KnownSort ExpressionSort where
  sortSing = SExpressionSort

instance KnownSort ConstructorNameSort where
  sortSing = SConstructorNameSort

instance KnownSort PatternListSort where
  sortSing = SPatternListSort

instance KnownSort PatternSort where
  sortSing = SPatternSort

instance KnownSort VariableNameSort where
  sortSing = SVariableNameSort

--------------------------------------------------------------------------------
-- SymbolType
--------------------------------------------------------------------------------

type data SymbolType where
  Regular :: SymbolType
  Auxiliary :: SymbolType

data SymbolTypeSing (symbolType :: SymbolType) where
  SRegular :: SymbolTypeSing Regular
  SAuxiliary :: SymbolTypeSing Auxiliary

deriving instance Eq (SymbolTypeSing symbolType)

deriving instance Show (SymbolTypeSing symbolType)

decSymbolTypeSing :: SymbolTypeSing symbolType1 -> SymbolTypeSing symbolType2 -> Maybe (symbolType1 :~: symbolType2)
decSymbolTypeSing SRegular SRegular = Just Refl
decSymbolTypeSing SAuxiliary SAuxiliary = Just Refl
decSymbolTypeSing _ _ = Nothing

--------------------------------------------------------------------------------
-- Symbol
--------------------------------------------------------------------------------

type data Symbol (symbolType :: SymbolType) where
  SourceFileSymbol :: (symbolType ~ Regular) => Symbol symbolType
  DeclarationTypeSignatureSymbol :: (symbolType ~ Regular) => Symbol symbolType
  DeclarationFunctionSymbol :: (symbolType ~ Regular) => Symbol symbolType
  ExpressionVariableSymbol :: (symbolType ~ Regular) => Symbol symbolType
  ExpressionConstructorSymbol :: (symbolType ~ Regular) => Symbol symbolType
  ExpressionFunctionTypeSymbol :: (symbolType ~ Regular) => Symbol symbolType
  ExpressionFunctionApplicationSymbol :: (symbolType ~ Regular) => Symbol symbolType
  ExpressionFunctionAbstractionSymbol :: (symbolType ~ Regular) => Symbol symbolType
  ExpressionAnnotationSymbol :: (symbolType ~ Regular) => Symbol symbolType
  ExpressionParenthesesSymbol :: (symbolType ~ Regular) => Symbol symbolType
  ConstructorNameSymbol :: (symbolType ~ Regular) => Symbol symbolType
  PatternListSymbol :: (symbolType ~ Regular) => Symbol symbolType
  PatternVariableSymbol :: (symbolType ~ Regular) => Symbol symbolType
  PatternConstructorSymbol :: (symbolType ~ Regular) => Symbol symbolType
  PatternParenthesesSymbol :: (symbolType ~ Regular) => Symbol symbolType
  VariableNameSymbol :: (symbolType ~ Regular) => Symbol symbolType
  ErrorSymbol :: (symbolType ~ Auxiliary) => Symbol symbolType
  MissingSymbol :: (symbolType ~ Auxiliary) => Symbol symbolType
  SortMismatchSymbol :: (symbolType ~ Auxiliary) => Symbol symbolType

data SymbolSing (symbolType :: SymbolType) (symbol :: Symbol symbolType) where
  SSourceFileSymbol :: SymbolSing Regular SourceFileSymbol
  SDeclarationTypeSignatureSymbol :: SymbolSing Regular DeclarationTypeSignatureSymbol
  SDeclarationFunctionSymbol :: SymbolSing Regular DeclarationFunctionSymbol
  SExpressionVariableSymbol :: SymbolSing Regular ExpressionVariableSymbol
  SExpressionConstructorSymbol :: SymbolSing Regular ExpressionConstructorSymbol
  SExpressionFunctionTypeSymbol :: SymbolSing Regular ExpressionFunctionTypeSymbol
  SExpressionFunctionApplicationSymbol :: SymbolSing Regular ExpressionFunctionApplicationSymbol
  SExpressionFunctionAbstractionSymbol :: SymbolSing Regular ExpressionFunctionAbstractionSymbol
  SExpressionAnnotationSymbol :: SymbolSing Regular ExpressionAnnotationSymbol
  SExpressionParenthesesSymbol :: SymbolSing Regular ExpressionParenthesesSymbol
  SConstructorNameSymbol :: SymbolSing Regular ConstructorNameSymbol
  SPatternListSymbol :: SymbolSing Regular PatternListSymbol
  SPatternVariableSymbol :: SymbolSing Regular PatternVariableSymbol
  SPatternConstructorSymbol :: SymbolSing Regular PatternConstructorSymbol
  SPatternParenthesesSymbol :: SymbolSing Regular PatternParenthesesSymbol
  SVariableNameSymbol :: SymbolSing Regular VariableNameSymbol
  SErrorSymbol :: SymbolSing Auxiliary ErrorSymbol
  SMissingSymbol :: SymbolSing Auxiliary MissingSymbol
  SSortMismatchSymbol :: SymbolSing Auxiliary SortMismatchSymbol

deriving instance Eq (SymbolSing sort symbol)

deriving instance Show (SymbolSing sort symbol)

decSymbolSing :: SymbolSing symbolType1 symbol1 -> SymbolSing symbolType2 symbol2 -> Maybe (symbolType1 :~: symbolType2, symbol1 :~~: symbol2)
decSymbolSing SSourceFileSymbol SSourceFileSymbol = Just (Refl, HRefl)
decSymbolSing SDeclarationTypeSignatureSymbol SDeclarationTypeSignatureSymbol = Just (Refl, HRefl)
decSymbolSing SDeclarationFunctionSymbol SDeclarationFunctionSymbol = Just (Refl, HRefl)
decSymbolSing SExpressionVariableSymbol SExpressionVariableSymbol = Just (Refl, HRefl)
decSymbolSing SExpressionConstructorSymbol SExpressionConstructorSymbol = Just (Refl, HRefl)
decSymbolSing SExpressionFunctionTypeSymbol SExpressionFunctionTypeSymbol = Just (Refl, HRefl)
decSymbolSing SExpressionFunctionApplicationSymbol SExpressionFunctionApplicationSymbol = Just (Refl, HRefl)
decSymbolSing SExpressionFunctionAbstractionSymbol SExpressionFunctionAbstractionSymbol = Just (Refl, HRefl)
decSymbolSing SExpressionAnnotationSymbol SExpressionAnnotationSymbol = Just (Refl, HRefl)
decSymbolSing SExpressionParenthesesSymbol SExpressionParenthesesSymbol = Just (Refl, HRefl)
decSymbolSing SConstructorNameSymbol SConstructorNameSymbol = Just (Refl, HRefl)
decSymbolSing SPatternListSymbol SPatternListSymbol = Just (Refl, HRefl)
decSymbolSing SPatternVariableSymbol SPatternVariableSymbol = Just (Refl, HRefl)
decSymbolSing SPatternConstructorSymbol SPatternConstructorSymbol = Just (Refl, HRefl)
decSymbolSing SPatternParenthesesSymbol SPatternParenthesesSymbol = Just (Refl, HRefl)
decSymbolSing SVariableNameSymbol SVariableNameSymbol = Just (Refl, HRefl)
decSymbolSing _ _ = Nothing

data SomeSymbolSing
  = forall (symbolType :: SymbolType) (symbol :: Symbol symbolType).
    SomeSymbolSing !(SymbolSing symbolType symbol)

instance Eq SomeSymbolSing where
  SomeSymbolSing symbolSing1 == SomeSymbolSing symbolSing2 =
    isJust (decSymbolSing symbolSing1 symbolSing2)

deriving instance Show SomeSymbolSing

--------------------------------------------------------------------------------
-- Getting the symbol types for symbols
--------------------------------------------------------------------------------

symbolToSymbolType :: SymbolSing symbolType symbol -> SymbolTypeSing symbolType
symbolToSymbolType = \case
  SSourceFileSymbol -> SRegular
  SDeclarationTypeSignatureSymbol -> SRegular
  SDeclarationFunctionSymbol -> SRegular
  SExpressionVariableSymbol -> SRegular
  SExpressionConstructorSymbol -> SRegular
  SExpressionFunctionTypeSymbol -> SRegular
  SExpressionFunctionApplicationSymbol -> SRegular
  SExpressionFunctionAbstractionSymbol -> SRegular
  SExpressionAnnotationSymbol -> SRegular
  SExpressionParenthesesSymbol -> SRegular
  SConstructorNameSymbol -> SRegular
  SPatternListSymbol -> SRegular
  SPatternVariableSymbol -> SRegular
  SPatternConstructorSymbol -> SRegular
  SPatternParenthesesSymbol -> SRegular
  SVariableNameSymbol -> SRegular
  SErrorSymbol -> SAuxiliary
  SMissingSymbol -> SAuxiliary
  SSortMismatchSymbol -> SAuxiliary

--------------------------------------------------------------------------------
-- Inferring sorts for regular symbols
--------------------------------------------------------------------------------

type family SymbolToSort (symbol :: Symbol Regular) :: Sort where
  SymbolToSort SourceFileSymbol = SourceFileSort
  SymbolToSort DeclarationTypeSignatureSymbol = DeclarationSort
  SymbolToSort DeclarationFunctionSymbol = DeclarationSort
  SymbolToSort ExpressionVariableSymbol = ExpressionSort
  SymbolToSort ExpressionConstructorSymbol = ExpressionSort
  SymbolToSort ExpressionFunctionTypeSymbol = ExpressionSort
  SymbolToSort ExpressionFunctionApplicationSymbol = ExpressionSort
  SymbolToSort ExpressionFunctionAbstractionSymbol = ExpressionSort
  SymbolToSort ExpressionAnnotationSymbol = ExpressionSort
  SymbolToSort ExpressionParenthesesSymbol = ExpressionSort
  SymbolToSort ConstructorNameSymbol = ConstructorNameSort
  SymbolToSort PatternListSymbol = PatternListSort
  SymbolToSort PatternVariableSymbol = PatternSort
  SymbolToSort PatternConstructorSymbol = PatternSort
  SymbolToSort PatternParenthesesSymbol = PatternSort
  SymbolToSort VariableNameSymbol = VariableNameSort

symbolToSort :: SymbolSing Regular symbol -> SortSing (SymbolToSort symbol)
symbolToSort = \case
  SSourceFileSymbol -> SSourceFileSort
  SDeclarationTypeSignatureSymbol -> SDeclarationSort
  SDeclarationFunctionSymbol -> SDeclarationSort
  SExpressionVariableSymbol -> SExpressionSort
  SExpressionConstructorSymbol -> SExpressionSort
  SExpressionFunctionTypeSymbol -> SExpressionSort
  SExpressionFunctionApplicationSymbol -> SExpressionSort
  SExpressionFunctionAbstractionSymbol -> SExpressionSort
  SExpressionAnnotationSymbol -> SExpressionSort
  SExpressionParenthesesSymbol -> SExpressionSort
  SConstructorNameSymbol -> SConstructorNameSort
  SPatternListSymbol -> SPatternListSort
  SPatternVariableSymbol -> SPatternSort
  SPatternConstructorSymbol -> SPatternSort
  SPatternParenthesesSymbol -> SPatternSort
  SVariableNameSymbol -> SVariableNameSort

--------------------------------------------------------------------------------
-- Well-sortedness for symbols
--------------------------------------------------------------------------------

type (:<) :: forall (symbolType :: SymbolType). Symbol symbolType -> Sort -> Type
data (:<) symbol sort where
  AuxiliaryWellSorted ::
    forall (symbol :: Symbol Auxiliary) (sort :: Sort).
    symbol :< sort
  RegularWellSorted ::
    forall (symbol :: Symbol Regular) (sort :: Sort).
    {-# UNPACK #-} !(SymbolToSort symbol :~: sort) ->
    symbol :< sort

deriving instance Eq (symbol :< sort)

deriving instance Show (symbol :< sort)

--------------------------------------------------------------------------------
-- Nodes
--------------------------------------------------------------------------------

data Node (sort :: Sort)
  = forall (symbolType :: SymbolType) (symbol :: Symbol symbolType).
  Node
  { nodeWellSorted :: !(symbol :< sort)
  , nodeContent :: !(NodeContent symbolType symbol)
  }

instance Eq (Node sort) where
  Node wellSorted1 content1 == Node wellSorted2 content2 =
    case nodeContentToSymbol content1 `decSymbolSing` nodeContentToSymbol content2 of
      Nothing -> False
      Just (Refl, HRefl) -> wellSorted1 == wellSorted2 && content1 == content2

deriving instance Show (Node sort)

data SomeNode
  = forall (symbolType :: SymbolType) (symbol :: Symbol symbolType).
  SomeNode
  { someNodeContent :: !(NodeContent symbolType symbol)
  }

instance Eq SomeNode where
  SomeNode content1 == SomeNode content2 =
    case nodeContentToSymbol content1 `decSymbolSing` nodeContentToSymbol content2 of
      Nothing -> False
      Just (Refl, HRefl) -> content1 == content2

deriving instance Show SomeNode

data NodeContent (symbolType :: SymbolType) (symbol :: Symbol symbolType) where
  SourceFileContent ::
    {-# UNPACK #-} !NodeId ->
    {-# UNPACK #-} !Range ->
    !(Children '[[Node DeclarationSort]]) ->
    NodeContent Regular SourceFileSymbol
  DeclarationTypeSignatureContent ::
    {-# UNPACK #-} !NodeId ->
    {-# UNPACK #-} !Range ->
    !(Children '[Node VariableNameSort, Node ExpressionSort]) ->
    NodeContent Regular DeclarationTypeSignatureSymbol
  DeclarationFunctionContent ::
    {-# UNPACK #-} !NodeId ->
    {-# UNPACK #-} !Range ->
    !(Children '[Node VariableNameSort, Maybe (Node PatternListSort), Node ExpressionSort]) ->
    NodeContent Regular DeclarationFunctionSymbol
  ExpressionVariableContent ::
    {-# UNPACK #-} !NodeId ->
    {-# UNPACK #-} !Range ->
    !(Children '[Node VariableNameSort]) ->
    NodeContent Regular ExpressionVariableSymbol
  ExpressionConstructorContent ::
    {-# UNPACK #-} !NodeId ->
    {-# UNPACK #-} !Range ->
    !(Children '[Node ConstructorNameSort]) ->
    NodeContent Regular ExpressionConstructorSymbol
  ExpressionFunctionTypeContent ::
    {-# UNPACK #-} !NodeId ->
    {-# UNPACK #-} !Range ->
    !(Children '[Node ExpressionSort, Node ExpressionSort]) ->
    NodeContent Regular ExpressionFunctionTypeSymbol
  ExpressionFunctionApplicationContent ::
    {-# UNPACK #-} !NodeId ->
    {-# UNPACK #-} !Range ->
    !(Children '[Node ExpressionSort, Node ExpressionSort]) ->
    NodeContent Regular ExpressionFunctionApplicationSymbol
  ExpressionFunctionAbstractionContent ::
    {-# UNPACK #-} !NodeId ->
    {-# UNPACK #-} !Range ->
    !(Children '[Node PatternListSort, Node ExpressionSort]) ->
    NodeContent Regular ExpressionFunctionAbstractionSymbol
  ExpressionAnnotationContent ::
    {-# UNPACK #-} !NodeId ->
    {-# UNPACK #-} !Range ->
    !(Children '[Node ExpressionSort, Node ExpressionSort]) ->
    NodeContent Regular ExpressionAnnotationSymbol
  ExpressionParenthesesContent ::
    {-# UNPACK #-} !NodeId ->
    {-# UNPACK #-} !Range ->
    !(Children '[Node ExpressionSort]) ->
    NodeContent Regular ExpressionParenthesesSymbol
  ConstructorNameContent ::
    {-# UNPACK #-} !NodeId ->
    {-# UNPACK #-} !Range ->
    NodeContent Regular ConstructorNameSymbol
  PatternListContent ::
    {-# UNPACK #-} !NodeId ->
    {-# UNPACK #-} !Range ->
    !(Children '[NonEmpty (Node PatternSort)]) ->
    NodeContent Regular PatternListSymbol
  PatternVariableContent ::
    {-# UNPACK #-} !NodeId ->
    {-# UNPACK #-} !Range ->
    !(Children '[Node VariableNameSort]) ->
    NodeContent Regular PatternVariableSymbol
  PatternConstructorContent ::
    {-# UNPACK #-} !NodeId ->
    {-# UNPACK #-} !Range ->
    !(Children '[Node ConstructorNameSort]) ->
    NodeContent Regular PatternConstructorSymbol
  PatternParenthesesContent ::
    {-# UNPACK #-} !NodeId ->
    {-# UNPACK #-} !Range ->
    !(Children '[Node PatternSort]) ->
    NodeContent Regular PatternParenthesesSymbol
  VariableNameContent ::
    {-# UNPACK #-} !NodeId ->
    {-# UNPACK #-} !Range ->
    NodeContent Regular VariableNameSymbol
  ErrorContent ::
    {-# UNPACK #-} !NodeId ->
    {-# UNPACK #-} !Range ->
    !(Children '[[SomeNode]]) ->
    NodeContent Auxiliary ErrorSymbol
  MissingContent ::
    {-# UNPACK #-} !NodeId ->
    {-# UNPACK #-} !Range ->
    NodeContent Auxiliary MissingSymbol
  SortMismatchContent ::
    !SomeNode ->
    NodeContent Auxiliary SortMismatchSymbol

deriving instance Eq (NodeContent symbolType symbol)

deriving instance Show (NodeContent symbolType symbol)

nodeContentToSymbol ::
  forall (symbolType :: SymbolType) (symbol :: Symbol symbolType).
  NodeContent symbolType symbol ->
  SymbolSing symbolType symbol
nodeContentToSymbol = \case
  SourceFileContent{} -> SSourceFileSymbol
  DeclarationTypeSignatureContent{} -> SDeclarationTypeSignatureSymbol
  DeclarationFunctionContent{} -> SDeclarationFunctionSymbol
  ExpressionVariableContent{} -> SExpressionVariableSymbol
  ExpressionConstructorContent{} -> SExpressionConstructorSymbol
  ExpressionFunctionTypeContent{} -> SExpressionFunctionTypeSymbol
  ExpressionFunctionApplicationContent{} -> SExpressionFunctionApplicationSymbol
  ExpressionFunctionAbstractionContent{} -> SExpressionFunctionAbstractionSymbol
  ExpressionAnnotationContent{} -> SExpressionAnnotationSymbol
  ExpressionParenthesesContent{} -> SExpressionParenthesesSymbol
  ConstructorNameContent{} -> SConstructorNameSymbol
  PatternListContent{} -> SPatternListSymbol
  PatternVariableContent{} -> SPatternVariableSymbol
  PatternConstructorContent{} -> SPatternConstructorSymbol
  PatternParenthesesContent{} -> SPatternParenthesesSymbol
  VariableNameContent{} -> SVariableNameSymbol
  ErrorContent{} -> SErrorSymbol
  MissingContent{} -> SMissingSymbol
  SortMismatchContent{} -> SSortMismatchSymbol

--------------------------------------------------------------------------------
-- Node Children as Heterogeneous Lists
--------------------------------------------------------------------------------

data ChildList (as :: [Type]) :: Type where
  Nil :: ChildList '[]
  Cons :: !a -> !(ChildList as) -> ChildList (a ': as)

deriving instance Eq (ChildList '[])

deriving instance Show (ChildList '[])

deriving instance (Eq a, Eq (ChildList as)) => Eq (ChildList (a ': as))

deriving instance (Show a, Show (ChildList as)) => Show (ChildList (a ': as))

newtype Children as = Children (ChildList as)

deriving instance (Eq (ChildList as)) => Eq (Children as)

deriving instance (Show (ChildList as)) => Show (Children as)

--------------------------------------------------------------------------------
-- Pattern Synonyms
--------------------------------------------------------------------------------

pattern SourceFile :: () => (sort ~ SourceFileSort) => NodeId -> Range -> [Node DeclarationSort] -> Node sort
pattern SourceFile nodeId nodeRange nodeChild0 =
  Node (RegularWellSorted Refl) (SourceFileContent nodeId nodeRange (Children (Cons nodeChild0 Nil)))

pattern DeclarationTypeSignature :: () => (sort ~ DeclarationSort) => NodeId -> Range -> Node VariableNameSort -> Node ExpressionSort -> Node sort
pattern DeclarationTypeSignature nodeId nodeRange nodeChild0 nodeChild1 =
  Node (RegularWellSorted Refl) (DeclarationTypeSignatureContent nodeId nodeRange (Children (Cons nodeChild0 (Cons nodeChild1 Nil))))

pattern DeclarationFunction :: () => (sort ~ DeclarationSort) => NodeId -> Range -> Node VariableNameSort -> Maybe (Node PatternListSort) -> Node ExpressionSort -> Node sort
pattern DeclarationFunction nodeId nodeRange nodeChild0 nodeChild1 nodeChild2 =
  Node (RegularWellSorted Refl) (DeclarationFunctionContent nodeId nodeRange (Children (Cons nodeChild0 (Cons nodeChild1 (Cons nodeChild2 Nil)))))

pattern ExpressionVariable :: () => (sort ~ ExpressionSort) => NodeId -> Range -> Node VariableNameSort -> Node sort
pattern ExpressionVariable nodeId nodeRange nodeChild0 =
  Node (RegularWellSorted Refl) (ExpressionVariableContent nodeId nodeRange (Children (Cons nodeChild0 Nil)))

pattern ExpressionConstructor :: () => (sort ~ ExpressionSort) => NodeId -> Range -> Node ConstructorNameSort -> Node sort
pattern ExpressionConstructor nodeId nodeRange nodeChild0 =
  Node (RegularWellSorted Refl) (ExpressionConstructorContent nodeId nodeRange (Children (Cons nodeChild0 Nil)))

pattern ExpressionFunctionType :: () => (sort ~ ExpressionSort) => NodeId -> Range -> Node ExpressionSort -> Node ExpressionSort -> Node sort
pattern ExpressionFunctionType nodeId nodeRange nodeChild0 nodeChild1 =
  Node (RegularWellSorted Refl) (ExpressionFunctionTypeContent nodeId nodeRange (Children (Cons nodeChild0 (Cons nodeChild1 Nil))))

pattern ExpressionFunctionApplication :: () => (sort ~ ExpressionSort) => NodeId -> Range -> Node ExpressionSort -> Node ExpressionSort -> Node sort
pattern ExpressionFunctionApplication nodeId nodeRange nodeChild0 nodeChild1 =
  Node (RegularWellSorted Refl) (ExpressionFunctionApplicationContent nodeId nodeRange (Children (Cons nodeChild0 (Cons nodeChild1 Nil))))

pattern ExpressionFunctionAbstraction :: () => (sort ~ ExpressionSort) => NodeId -> Range -> Node PatternListSort -> Node ExpressionSort -> Node sort
pattern ExpressionFunctionAbstraction nodeId nodeRange nodeChild0 nodeChild1 =
  Node (RegularWellSorted Refl) (ExpressionFunctionAbstractionContent nodeId nodeRange (Children (Cons nodeChild0 (Cons nodeChild1 Nil))))

pattern ExpressionAnnotation :: () => (sort ~ ExpressionSort) => NodeId -> Range -> Node ExpressionSort -> Node ExpressionSort -> Node sort
pattern ExpressionAnnotation nodeId nodeRange nodeChild0 nodeChild1 =
  Node (RegularWellSorted Refl) (ExpressionAnnotationContent nodeId nodeRange (Children (Cons nodeChild0 (Cons nodeChild1 Nil))))

pattern ExpressionParentheses :: () => (sort ~ ExpressionSort) => NodeId -> Range -> Node ExpressionSort -> Node sort
pattern ExpressionParentheses nodeId nodeRange nodeChild0 =
  Node (RegularWellSorted Refl) (ExpressionParenthesesContent nodeId nodeRange (Children (Cons nodeChild0 Nil)))

pattern ConstructorName :: () => (sort ~ ConstructorNameSort) => NodeId -> Range -> Node sort
pattern ConstructorName nodeId nodeRange =
  Node (RegularWellSorted Refl) (ConstructorNameContent nodeId nodeRange)

pattern PatternList :: () => (sort ~ PatternListSort) => NodeId -> Range -> NonEmpty (Node PatternSort) -> Node sort
pattern PatternList nodeId nodeRange nodeChild0 =
  Node (RegularWellSorted Refl) (PatternListContent nodeId nodeRange (Children (Cons nodeChild0 Nil)))

pattern PatternVariable :: () => (sort ~ PatternSort) => NodeId -> Range -> Node VariableNameSort -> Node sort
pattern PatternVariable nodeId nodeRange nodeChild0 =
  Node (RegularWellSorted Refl) (PatternVariableContent nodeId nodeRange (Children (Cons nodeChild0 Nil)))

pattern PatternConstructor :: () => (sort ~ PatternSort) => NodeId -> Range -> Node ConstructorNameSort -> Node sort
pattern PatternConstructor nodeId nodeRange nodeChild0 =
  Node (RegularWellSorted Refl) (PatternConstructorContent nodeId nodeRange (Children (Cons nodeChild0 Nil)))

pattern PatternParentheses :: () => (sort ~ PatternSort) => NodeId -> Range -> Node PatternSort -> Node sort
pattern PatternParentheses nodeId nodeRange nodeChild0 =
  Node (RegularWellSorted Refl) (PatternParenthesesContent nodeId nodeRange (Children (Cons nodeChild0 Nil)))

pattern VariableName :: () => (sort ~ VariableNameSort) => NodeId -> Range -> Node sort
pattern VariableName nodeId nodeRange =
  Node (RegularWellSorted Refl) (VariableNameContent nodeId nodeRange)

pattern Error :: NodeId -> Range -> [SomeNode] -> Node sort
pattern Error nodeId nodeRange nodeChild0 =
  Node AuxiliaryWellSorted (ErrorContent nodeId nodeRange (Children (Cons nodeChild0 Nil)))

pattern Missing :: NodeId -> Range -> Node sort
pattern Missing nodeId nodeRange =
  Node AuxiliaryWellSorted (MissingContent nodeId nodeRange)

pattern SortMismatch :: SomeNode -> Node sort
pattern SortMismatch nodeChild0 =
  Node AuxiliaryWellSorted (SortMismatchContent nodeChild0)

{-# COMPLETE
  SourceFile
  , DeclarationTypeSignature
  , DeclarationFunction
  , ExpressionVariable
  , ExpressionConstructor
  , ExpressionFunctionType
  , ExpressionFunctionApplication
  , ExpressionFunctionAbstraction
  , ExpressionAnnotation
  , ExpressionParentheses
  , ConstructorName
  , PatternList
  , PatternVariable
  , PatternConstructor
  , PatternParentheses
  , VariableName
  , Error
  , Missing
  , SortMismatch
  #-}

--------------------------------------------------------------------------------
-- Symbol Table
--------------------------------------------------------------------------------

newtype SymbolTable = SymbolTable {unSymbolTable :: IntMap SomeSymbolSing}

mkSymbolTable :: TS.Language -> IO SymbolTable
mkSymbolTable language =
  fmap (SymbolTable . IM.fromList) . sequence $
    [ mkEntry "source_file" (SomeSymbolSing SSourceFileSymbol)
    , mkEntry "declaration_type_signature" (SomeSymbolSing SDeclarationTypeSignatureSymbol)
    , mkEntry "declaration_function" (SomeSymbolSing SDeclarationFunctionSymbol)
    , mkEntry "expression_variable" (SomeSymbolSing SExpressionVariableSymbol)
    , mkEntry "expression_constructor" (SomeSymbolSing SExpressionConstructorSymbol)
    , mkEntry "expression_function_type" (SomeSymbolSing SExpressionFunctionTypeSymbol)
    , mkEntry "expression_function_application" (SomeSymbolSing SExpressionFunctionApplicationSymbol)
    , mkEntry "expression_function_abstraction" (SomeSymbolSing SExpressionFunctionAbstractionSymbol)
    , mkEntry "expression_annotation" (SomeSymbolSing SExpressionAnnotationSymbol)
    , mkEntry "expression_parentheses" (SomeSymbolSing SExpressionParenthesesSymbol)
    , mkEntry "constructor_name" (SomeSymbolSing SConstructorNameSymbol)
    , mkEntry "pattern_list" (SomeSymbolSing SPatternListSymbol)
    , mkEntry "pattern_variable" (SomeSymbolSing SPatternVariableSymbol)
    , mkEntry "pattern_constructor" (SomeSymbolSing SPatternConstructorSymbol)
    , mkEntry "pattern_parentheses" (SomeSymbolSing SPatternParenthesesSymbol)
    , mkEntry "variable_name" (SomeSymbolSing SVariableNameSymbol)
    ]
 where
  mkEntry :: String -> SomeSymbolSing -> IO (Int, SomeSymbolSing)
  mkEntry grammarType someSymbol = do
    (,someSymbol) . fromIntegral <$> TS.languageSymbolForGrammarType language (BSC.pack grammarType) True

--------------------------------------------------------------------------------
-- Node Cache
--------------------------------------------------------------------------------

newtype AstCache = AstCache {unAstCache :: IntMap SomeNode}
  deriving (Show, Semigroup, Monoid)

insertSomeNode :: NodeId -> SomeNode -> AstCache -> AstCache
insertSomeNode nodeId someNode astCacheMap =
  AstCache (IM.insert (unWrapTSNodeId nodeId) someNode (unAstCache astCacheMap))

--------------------------------------------------------------------------------
-- Parser Monad
--------------------------------------------------------------------------------

data PState = PState
  { currentNode :: {-# UNPACK #-} !TS.Node
  , newCache :: {-# NOUNPACK #-} !AstCache
  }

data PEnv = PEnv
  { symbolTable :: {-# UNPACK #-} !SymbolTable
  , treeCursor :: {-# UNPACK #-} !TS.TreeCursor
  , oldCache :: {-# UNPACK #-} !AstCache
  }

newtype P a = P {unP :: ReaderT PEnv (MaybeT (StateT PState IO)) a}
  deriving (Functor, Applicative, Monad, MonadIO, MonadReader PEnv, MonadState PState, Alternative, MonadPlus)

getCurrentNode :: P TS.Node
getCurrentNode = gets currentNode

putCurrentNode :: TS.Node -> P ()
putCurrentNode node = modify' (\pstate -> pstate{currentNode = node})

getSymbol :: TS.Node -> P SomeSymbolSing
getSymbol node = do
  currentNodeIsError <- liftIO (TS.nodeIsError node)
  if currentNodeIsError
    then pure (SomeSymbolSing SErrorSymbol)
    else do
      currentNodeIsMissing <- liftIO (TS.nodeIsMissing node)
      if currentNodeIsMissing
        then pure (SomeSymbolSing SMissingSymbol)
        else do
          symbol <- liftIO (TS.nodeSymbol node)
          asks ((IM.! fromIntegral symbol) . unSymbolTable . symbolTable)

emitSomeNode :: NodeId -> SomeNode -> P SomeNode
emitSomeNode nodeId someNode = modify' updatePState >> pure someNode
 where
  updatePState pstate = pstate{newCache = insertSomeNode nodeId someNode (newCache pstate)}

lookupSomeNode :: NodeId -> P SomeNode
lookupSomeNode nodeId =
  maybe mzero pure . IM.lookup (unWrapTSNodeId nodeId) . unAstCache =<< asks oldCache

gotoParent :: P ()
gotoParent = do
  treeCursor <- asks treeCursor
  success <- liftIO (TS.treeCursorGotoParent treeCursor)
  if not success
    then mzero
    else do
      currentNode <- liftIO (TS.treeCursorCurrentNode treeCursor)
      putCurrentNode currentNode

gotoFirstNamedChild :: P ()
gotoFirstNamedChild = do
  treeCursor <- asks treeCursor
  success <- liftIO (TS.treeCursorGotoFirstChild treeCursor)
  if not success
    then mzero
    else do
      currentNode <- liftIO (TS.treeCursorCurrentNode treeCursor)
      currentNodeIsNamed <- liftIO (TS.nodeIsNamed currentNode)
      if currentNodeIsNamed
        then putCurrentNode currentNode
        else gotoNextNamedSibling

gotoNextNamedSibling :: P ()
gotoNextNamedSibling = do
  treeCursor <- asks treeCursor
  success <- liftIO (TS.treeCursorGotoNextSibling treeCursor)
  if not success
    then mzero
    else do
      currentNode <- liftIO (TS.treeCursorCurrentNode treeCursor)
      currentNodeIsNamed <- liftIO (TS.nodeIsNamed currentNode)
      if currentNodeIsNamed
        then putCurrentNode currentNode
        else gotoNextNamedSibling

--------------------------------------------------------------------------------
-- Parser Class
--------------------------------------------------------------------------------

class HasParser a where
  p :: P a

instance HasParser NodeId where
  p :: P NodeId
  p = TS.nodeId <$> getCurrentNode

instance HasParser (ChildList '[]) where
  p :: P (ChildList '[])
  p = pure Nil

instance (HasParser a) => HasParser (ChildList (a ': '[])) where
  p :: (HasParser a) => P (ChildList '[a])
  p = Cons <$> p <*> pure Nil

instance (HasParser a, HasParser (ChildList (b ': bs))) => HasParser (ChildList (a ': b ': bs)) where
  p :: (HasParser a, HasParser (ChildList (b : bs))) => P (ChildList (a ': b ': bs))
  p = Cons <$> p <* gotoNextNamedSibling <*> p

instance (HasParser (ChildList as)) => HasParser (Children as) where
  p :: (HasParser (ChildList as)) => P (Children as)
  p = Children <$> (gotoFirstNamedChild *> p <* gotoParent)

instance (HasParser a) => HasParser (Maybe a) where
  p :: (HasParser a) => P (Maybe a)
  p = optional p

instance (HasParser a) => HasParser [a] where
  p :: (HasParser a) => P [a]
  p = pPostFence p gotoNextNamedSibling

instance (HasParser a) => HasParser (NonEmpty a) where
  p :: (HasParser a) => P (NonEmpty a)
  p = pPostFence1 p gotoNextNamedSibling

instance HasParser Range where
  p :: P Range
  p = liftIO . TS.nodeRange =<< getCurrentNode

pPostFence :: P a -> P () -> P [a]
pPostFence post fence = postFence
 where
  fencePost = fence *> postFence <|> pure []
  postFence = ((:) <$> post <*> fencePost) <|> pure []

pPostFence1 :: P a -> P () -> P (NonEmpty a)
pPostFence1 post fence = postFence
 where
  fencePost = fence *> pPostFence post fence <|> pure []
  postFence = (:|) <$> post <*> fencePost

--------------------------------------------------------------------------------
-- Node Parser
--------------------------------------------------------------------------------

instance (KnownSort sort) => HasParser (Node sort) where
  p :: (KnownSort sort) => P (Node sort)
  p = pNode

pNode :: (KnownSort sort) => P (Node sort)
pNode =
  pSomeNode >>= \(SomeNode nodeContent) -> do
    let symbol = nodeContentToSymbol nodeContent
    let symbolType = symbolToSymbolType symbol
    case symbolType of
      SRegular ->
        pure $
          case decSortSing (symbolToSort symbol) sortSing of
            Just prf -> Node (RegularWellSorted prf) nodeContent
            Nothing -> SortMismatch (SomeNode nodeContent)
      SAuxiliary -> pure $ Node AuxiliaryWellSorted nodeContent

instance HasParser SomeNode where
  p :: P SomeNode
  p = pSomeNode

pSomeNode :: P SomeNode
pSomeNode = pSomeNode' =<< getCurrentNode
 where
  pSomeNode' :: TS.Node -> P SomeNode
  pSomeNode' node = emitSomeNode nodeId =<< tryCache <|> tryParse
   where
    nodeId = TS.nodeId node
    tryCache = do
      nodeHasChanges <- liftIO (TS.nodeHasChanges node)
      if nodeHasChanges then lookupSomeNode nodeId else mzero
    tryParse = do
      getSymbol node >>= \(SomeSymbolSing symbol) -> do
        -- grammarType <- liftIO (TS.nodeGrammarTypeAsString node)
        -- liftIO (printf "(%s %#x) -> %s\n" grammarType (unWrapTSNodeId nodeId) (show symbol))
        SomeNode <$> pNodeContent symbol

pNodeContent :: SymbolSing symbolType symbol -> P (NodeContent symbolType symbol)
pNodeContent = \case
  SSourceFileSymbol -> SourceFileContent <$> p <*> p <*> p
  SDeclarationTypeSignatureSymbol -> DeclarationTypeSignatureContent <$> p <*> p <*> p
  SDeclarationFunctionSymbol -> DeclarationFunctionContent <$> p <*> p <*> p
  SExpressionVariableSymbol -> ExpressionVariableContent <$> p <*> p <*> p
  SExpressionConstructorSymbol -> ExpressionConstructorContent <$> p <*> p <*> p
  SExpressionFunctionTypeSymbol -> ExpressionFunctionTypeContent <$> p <*> p <*> p
  SExpressionFunctionApplicationSymbol -> ExpressionFunctionApplicationContent <$> p <*> p <*> p
  SExpressionFunctionAbstractionSymbol -> ExpressionFunctionAbstractionContent <$> p <*> p <*> p
  SExpressionAnnotationSymbol -> ExpressionAnnotationContent <$> p <*> p <*> p
  SExpressionParenthesesSymbol -> ExpressionParenthesesContent <$> p <*> p <*> p
  SConstructorNameSymbol -> ConstructorNameContent <$> p <*> p
  SPatternListSymbol -> PatternListContent <$> p <*> p <*> p
  SPatternVariableSymbol -> PatternVariableContent <$> p <*> p <*> p
  SPatternConstructorSymbol -> PatternConstructorContent <$> p <*> p <*> p
  SPatternParenthesesSymbol -> PatternParenthesesContent <$> p <*> p <*> p
  SVariableNameSymbol -> VariableNameContent <$> p <*> p
  SErrorSymbol -> ErrorContent <$> p <*> p <*> p
  SMissingSymbol -> MissingContent <$> p <*> p
  SSortMismatchSymbol -> SortMismatchContent <$> p

--------------------------------------------------------------------------------
-- Pretty Printing
--------------------------------------------------------------------------------

instance Pretty (Node sort) where
  pretty (Node _wellSorted content) = pretty content
  prettyList = sep . fmap pretty

instance Pretty SomeNode where
  pretty (SomeNode content) = pretty content
  prettyList = sep . fmap pretty

instance Pretty (NodeContent symbolType symbol) where
  pretty = \case
    SourceFileContent _nodeId _nodeRange (Children (Cons nodeChild0 Nil)) ->
      parens . nest 2 . sep $
        ["source_file", pretty nodeChild0]
    DeclarationTypeSignatureContent _nodeId _nodeRange (Children (Cons nodeChild0 (Cons nodeChild1 Nil))) ->
      parens . nest 2 . sep $
        ["declaration_type_signature", pretty nodeChild0, pretty nodeChild1]
    DeclarationFunctionContent _nodeId _nodeRange (Children (Cons nodeChild0 (Cons nodeChild1 (Cons nodeChild2 Nil)))) ->
      parens . nest 2 . sep $
        ["declaration_function", pretty nodeChild0, pretty nodeChild1, pretty nodeChild2]
    ExpressionVariableContent _nodeId _nodeRange (Children (Cons nodeChild0 Nil)) ->
      parens . nest 2 . sep $
        ["expression_variable", pretty nodeChild0]
    ExpressionConstructorContent _nodeId _nodeRange (Children (Cons nodeChild0 Nil)) ->
      parens . nest 2 . sep $
        ["expression_constructor", pretty nodeChild0]
    ExpressionFunctionTypeContent _nodeId _nodeRange (Children (Cons nodeChild0 (Cons nodeChild1 Nil))) ->
      parens . nest 2 . sep $
        ["expression_function_type", pretty nodeChild0, pretty nodeChild1]
    ExpressionFunctionApplicationContent _nodeId _nodeRange (Children (Cons nodeChild0 (Cons nodeChild1 Nil))) ->
      parens . nest 2 . sep $
        ["expression_function_application", pretty nodeChild0, pretty nodeChild1]
    ExpressionFunctionAbstractionContent _nodeId _nodeRange (Children (Cons nodeChild0 (Cons nodeChild1 Nil))) ->
      parens . nest 2 . sep $
        ["expression_function_abstraction", pretty nodeChild0, pretty nodeChild1]
    ExpressionAnnotationContent _nodeId _nodeRange (Children (Cons nodeChild0 (Cons nodeChild1 Nil))) ->
      parens . nest 2 . sep $
        ["expression_annotation", pretty nodeChild0, pretty nodeChild1]
    ExpressionParenthesesContent _nodeId _nodeRange (Children (Cons nodeChild0 Nil)) ->
      parens . nest 2 . sep $
        ["expression_parentheses", pretty nodeChild0]
    ConstructorNameContent _nodeId _nodeRange ->
      "(constructor_name)"
    PatternListContent _nodeId _nodeRange (Children (Cons nodeChild0 Nil)) ->
      parens . nest 2 . sep $
        ["pattern_list", pretty nodeChild0]
    PatternVariableContent _nodeId _nodeRange (Children (Cons nodeChild0 Nil)) ->
      parens . nest 2 . sep $
        ["pattern_variable", pretty nodeChild0]
    PatternConstructorContent _nodeId _nodeRange (Children (Cons nodeChild0 Nil)) ->
      parens . nest 2 . sep $
        ["pattern_constructor", pretty nodeChild0]
    PatternParenthesesContent _nodeId _nodeRange (Children (Cons nodeChild0 Nil)) ->
      parens . nest 2 . sep $
        ["pattern_parentheses", pretty nodeChild0]
    VariableNameContent _nodeId _nodeRange ->
      "(variable_name)"
    ErrorContent _nodeId _nodeRange nodeChildren ->
      parens . nest 2 . sep $
        ["error", pretty nodeChildren]
    MissingContent _nodeId _nodeRange ->
      "(missing)"
    SortMismatchContent nodeChildren ->
      parens . nest 2 . sep $
        ["error", pretty nodeChildren]

instance Pretty (ChildList '[]) where
  pretty = mempty

instance (Pretty a) => Pretty (ChildList (a ': '[])) where
  pretty (Cons x Nil) = pretty x

instance (Pretty a, Pretty (ChildList (b ': bs))) => Pretty (ChildList (a ': b ': bs)) where
  pretty (Cons x xs) = pretty x <> line <> pretty xs

instance (Pretty (ChildList as)) => Pretty (Children as) where
  pretty (Children xs) = pretty xs
