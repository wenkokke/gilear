-- WARNING: This module was generated by `tree-sitter-generate-ast`.
--
--   build-depends:
--     , base          >=4.13 && <5
--     , bytestring    >=0.12 && <0.13
--     , containers    >=0.6  && <0.8
--     , mtl           >=2.3  && <2.4
--     , transformers  >=0.6  && <0.7
--     , tree-sitter
--

{-# LANGUAGE DataKinds #-}
{-# LANGUAGE LambdaCase #-}
{-# LANGUAGE PatternSynonyms #-}
{-# LANGUAGE StandaloneKindSignatures #-}
{-# LANGUAGE TypeData #-}
{-# LANGUAGE TypeFamilies #-}
{-# LANGUAGE ImportQualifiedPost #-}
{-# LANGUAGE UndecidableInstances #-}

{-+}
module ${moduleName} (
{+-}
  Sort (..),
  SortSing (..),
  SymbolType (..),
  SymbolTypeSing (..),
  Symbol (..),
  SymbolSing (..),
  SomeSymbolSing (..),
  SymbolTable,
  type (:<) (..),
  Node
  (
{-+}
${for(dataTypes)}
${for(it.constrs)}
    ${it.name.camelCase},
${endfor}${endfor}
{+-}
    Error,
    Missing,
    SortMismatch
  ),
  NodeContent (..),
  Children (..),
  ChildList (..),
  SomeNode (..),
  SomeNodeCache,
  mkSymbolTable,
  nodeContentToSymbol,
  parseTree,
  symbolToSymbolType,
  symbolToSort,
) where

import Control.Applicative (Alternative (..), optional)
import Control.Monad (MonadPlus (..))
import Control.Monad.IO.Class (MonadIO (..))
import Control.Monad.Reader (MonadReader, ReaderT (..), asks)
import Control.Monad.State.Strict (MonadState (..), StateT (..), modify', gets)
import Control.Monad.Trans.Maybe (MaybeT (..))
import Data.ByteString.Char8 qualified as BSC
import Data.IntMap.Strict (IntMap)
import Data.IntMap.Strict qualified as IM
import Data.Kind (Type)
import Data.List.NonEmpty (NonEmpty (..))
import Data.Type.Equality (type (:~:) (..))
import TreeSitter (NodeId (..), Range (..))
import TreeSitter qualified as TS

--------------------------------------------------------------------------------
-- Entry point
--------------------------------------------------------------------------------

{-+}
parseTree :: SymbolTable -> TS.Tree -> IO (Maybe (Node ${startSort.camelCase}Sort, SomeNodeCache))
parseTree symbolTable tree = do
  rootNode <- TS.treeRootNode tree
  treeCursor <- TS.treeCursorNew rootNode
  let pEnv = PEnv symbolTable treeCursor mempty
  let pState = PState rootNode mempty
  (maybeNode, pState') <- runStateT (runMaybeT (runReaderT (unP p) pEnv)) pState
  pure $$ fmap (,newCache pState') maybeNode
{+-}

--------------------------------------------------------------------------------
-- Sort
--------------------------------------------------------------------------------

type data Sort where
{-+}
${for(dataTypes)}
  ${it.name.camelCase}Sort :: Sort
${endfor}
{+-}

data SortSing (sort :: Sort) where
{-+}
${for(dataTypes)}
  S${it.name.camelCase}Sort :: SortSing ${it.name.camelCase}Sort
${endfor}
{+-}

deriving instance Show (SortSing sort)

decSortSing :: SortSing sort1 -> SortSing sort2 -> Maybe (sort1 :~: sort2)
{-+}
${for(dataTypes)}
decSortSing S${it.name.camelCase}Sort S${it.name.camelCase}Sort = Just Refl
${endfor}
{+-}
decSortSing _ _ = Nothing

class KnownSort sort where
  sortSing :: SortSing sort

{-+}
${for(dataTypes)}
instance KnownSort ${it.name.camelCase}Sort where
  sortSing = S${it.name.camelCase}Sort

${endfor}
{+-}

--------------------------------------------------------------------------------
-- SymbolType
--------------------------------------------------------------------------------

type data SymbolType where
  Regular :: SymbolType
  Auxiliary :: SymbolType

data SymbolTypeSing (symbolType :: SymbolType) where
  SRegular :: SymbolTypeSing Regular
  SAuxiliary :: SymbolTypeSing Auxiliary

--------------------------------------------------------------------------------
-- Symbol
--------------------------------------------------------------------------------

type data Symbol (symbolType :: SymbolType) where
{-+}
${for(dataTypes)}
${for(it.constrs)}
  ${it.name.camelCase}Symbol :: (symbolType ~ Regular) => Symbol symbolType
${endfor}
${endfor}
{+-}
  ErrorSymbol :: (symbolType ~ Auxiliary) => Symbol symbolType
  MissingSymbol :: (symbolType ~ Auxiliary) => Symbol symbolType
  SortMismatchSymbol :: (symbolType ~ Auxiliary) => Symbol symbolType

data SymbolSing (symbolType :: SymbolType) (symbol :: Symbol symbolType) where
{-+}
${for(dataTypes)}
${for(it.constrs)}
  S${it.name.camelCase}Symbol :: SymbolSing Regular ${it.name.camelCase}Symbol
${endfor}
${endfor}
{+-}
  SErrorSymbol :: SymbolSing Auxiliary ErrorSymbol
  SMissingSymbol :: SymbolSing Auxiliary MissingSymbol
  SSortMismatchSymbol :: SymbolSing Auxiliary SortMismatchSymbol

deriving instance Show (SymbolSing sort symbol)

data SomeSymbolSing
  = forall (symbolType :: SymbolType) (symbol :: Symbol symbolType).
    SomeSymbolSing !(SymbolSing symbolType symbol)

deriving instance Show SomeSymbolSing

--------------------------------------------------------------------------------
-- Getting the symbol types for symbols
--------------------------------------------------------------------------------

symbolToSymbolType :: SymbolSing symbolType symbol -> SymbolTypeSing symbolType
symbolToSymbolType = \case
{-+}
${for(dataTypes)}
${for(it.constrs)}
  S${it.name.camelCase}Symbol -> SRegular
${endfor}
${endfor}
{+-}
  SErrorSymbol -> SAuxiliary
  SMissingSymbol -> SAuxiliary
  SSortMismatchSymbol -> SAuxiliary

--------------------------------------------------------------------------------
-- Inferring sorts for regular symbols
--------------------------------------------------------------------------------

type family SymbolSort (symbol :: Symbol Regular) :: Sort where
{-+}
${for(dataTypes)}
${for(it.constrs)}
  SymbolSort ${it.name.camelCase}Symbol = ${it.sort.camelCase}Sort
${endfor}
${endfor}
{+-}

symbolToSort :: SymbolSing Regular symbol -> SortSing (SymbolSort symbol)
symbolToSort = \case
{-+}
${for(dataTypes)}
${for(it.constrs)}
  S${it.name.camelCase}Symbol -> S${it.sort.camelCase}Sort
${endfor}
${endfor}
{+-}

--------------------------------------------------------------------------------
-- Well-sortedness for symbols
--------------------------------------------------------------------------------

type (:<) :: forall (symbolType :: SymbolType). Symbol symbolType -> Sort -> Type
data (:<) symbol sort where
  AuxiliaryWellSorted ::
    forall (symbol :: Symbol Auxiliary) (sort :: Sort).
    symbol :< sort
  RegularWellSorted ::
    forall (symbol :: Symbol Regular) (sort :: Sort).
    !(SymbolSort symbol :~: sort) ->
    symbol :< sort

deriving instance Show (symbol :< sort)

--------------------------------------------------------------------------------
-- Nodes
--------------------------------------------------------------------------------

data Node (sort :: Sort)
  = forall (symbolType :: SymbolType) (symbol :: Symbol symbolType).
  Node
  { nodeWellSorted :: !(symbol :< sort)
  , nodeContent :: !(NodeContent symbolType symbol)
  }

deriving instance Show (Node sort)

data SomeNode
  = forall (symbolType :: SymbolType) (symbol :: Symbol symbolType).
  SomeNode
  { someNodeContent :: !(NodeContent symbolType symbol)
  }

deriving instance Show SomeNode

data NodeContent (symbolType :: SymbolType) (symbol :: Symbol symbolType) where
{-+}
${for(dataTypes)}
${for(it.constrs)}
  ${it.name.camelCase}Content ::
    !NodeId ->
    !Range ->
${if(it.hasChildren)}
    !(Children '[${for(it.fields)}${it.type}${sep}, ${endfor}]) ->  
${endif}
    NodeContent Regular ${it.name.camelCase}Symbol
${endfor}
${endfor}
{+-}
  ErrorContent ::
    !NodeId ->
    !Range ->
    !(Children '[[SomeNode]]) ->
    NodeContent Auxiliary ErrorSymbol
  MissingContent ::
    !NodeId ->
    !Range ->
    NodeContent Auxiliary MissingSymbol
  SortMismatchContent ::
    !SomeNode ->
    NodeContent Auxiliary SortMismatchSymbol

deriving instance Show (NodeContent symbolType symbol)

nodeContentToSymbol ::
  forall (symbolType :: SymbolType) (symbol :: Symbol symbolType).
  NodeContent symbolType symbol ->
  SymbolSing symbolType symbol
nodeContentToSymbol = \case
{-+}
${for(dataTypes)}
${for(it.constrs)}
  ${it.name.camelCase}Content{} -> S${it.name.camelCase}Symbol
${endfor}
${endfor}
{+-}
  ErrorContent{} -> SErrorSymbol
  MissingContent{} -> SMissingSymbol
  SortMismatchContent{} -> SSortMismatchSymbol

--------------------------------------------------------------------------------
-- Node Children as Heterogeneous Lists
--------------------------------------------------------------------------------

data ChildList (as :: [Type]) :: Type where
  Nil :: ChildList '[]
  Cons :: !a -> !(ChildList as) -> ChildList (a ': as)

deriving instance Show (ChildList '[])

deriving instance (Show a, Show (ChildList as)) => Show (ChildList (a ': as))

newtype Children as = Children (ChildList as)

deriving instance (Show (ChildList as)) => Show (Children as)

--------------------------------------------------------------------------------
-- Pattern Synonyms
--------------------------------------------------------------------------------

{-+}
${for(dataTypes)}
${for(it.constrs)}
pattern ${it.name.camelCase} :: NodeId -> Range -> ${if(it.hasChildren)}${for(it.fields)}${it.type} -> ${endfor}${endif}Node ${it.sort.camelCase}Sort
pattern ${it.name.camelCase} nodeId nodeRange ${if(it.hasChildren)}${for(it.fields)}nodeChild${it.index}${sep} ${endfor}${endif} =
  Node (RegularWellSorted Refl) (${it.name.camelCase}Content nodeId nodeRange${if(it.hasChildren)} (Children${for(it.fields)} (Cons nodeChild${it.index}${endfor} Nil${for(it.fields)})${endfor})${endif})

${endfor}
${endfor}
{+-}

pattern Error :: NodeId -> Range -> [SomeNode] -> Node sort
pattern Error nodeId nodeRange nodeChild0 =
  Node AuxiliaryWellSorted (ErrorContent nodeId nodeRange (Children (Cons nodeChild0 Nil)))

pattern Missing :: NodeId -> Range -> Node sort
pattern Missing nodeId nodeRange =
  Node AuxiliaryWellSorted (MissingContent nodeId nodeRange)

pattern SortMismatch :: SomeNode -> Node sort
pattern SortMismatch nodeChild0 =
  Node AuxiliaryWellSorted (SortMismatchContent nodeChild0)

{-# COMPLETE
{-+}
${for(dataTypes)}
${for(it.constrs)}
  ${it.name.camelCase},
${endfor}${endfor}
{+-}
  Error,
  Missing,
  SortMismatch
  #-}

--------------------------------------------------------------------------------
-- Symbol Table
--------------------------------------------------------------------------------

newtype SymbolTable = SymbolTable {unSymbolTable :: IntMap SomeSymbolSing}

mkSymbolTable :: TS.Language -> IO SymbolTable
mkSymbolTable language =
  fmap (SymbolTable . IM.fromList) . sequence $
{-+}
${for(dataTypes/first)}
${for(it.constrs/first)}
    [ mkEntry "${it.name.text}" (SomeSymbolSing S${it.name.camelCase}Symbol)
${endfor}
${for(it.constrs/rest)}
    , mkEntry "${it.name.text}" (SomeSymbolSing S${it.name.camelCase}Symbol)
${endfor}
${endfor}
${for(dataTypes/rest)}
${for(it.constrs)}
    , mkEntry "${it.name.text}" (SomeSymbolSing S${it.name.camelCase}Symbol)
${endfor}
${endfor}
{+-}
    ]
 where
  mkEntry :: String -> SomeSymbolSing -> IO (Int, SomeSymbolSing)
  mkEntry grammarType someSymbol = do
    (,someSymbol) . fromIntegral <$> TS.languageSymbolForGrammarType language (BSC.pack grammarType) True

--------------------------------------------------------------------------------
-- Node Cache
--------------------------------------------------------------------------------

newtype SomeNodeCache = SomeNodeCache {unSomeNodeCache :: IntMap SomeNode}
  deriving (Show, Semigroup, Monoid)

insertSomeNode :: NodeId -> SomeNode -> SomeNodeCache -> SomeNodeCache
insertSomeNode nodeId someNode someNodeCacheMap =
  SomeNodeCache (IM.insert (unWrapTSNodeId nodeId) someNode (unSomeNodeCache someNodeCacheMap))

--------------------------------------------------------------------------------
-- Parser Monad
--------------------------------------------------------------------------------

data PState = PState
  { currentNode :: TS.Node
  , newCache :: !SomeNodeCache
  }

data PEnv = PEnv
  { symbolTable :: !SymbolTable
  , treeCursor :: !TS.TreeCursor
  , oldCache :: !SomeNodeCache
  }

newtype P a = P {unP :: ReaderT PEnv (MaybeT (StateT PState IO)) a}
  deriving (Functor, Applicative, Monad, MonadIO, MonadReader PEnv, MonadState PState, Alternative, MonadPlus)

getCurrentNode :: P TS.Node
getCurrentNode = gets currentNode

putCurrentNode :: TS.Node -> P ()
putCurrentNode node = modify' (\pstate -> pstate{currentNode = node})

getSymbol :: TS.Node -> P SomeSymbolSing
getSymbol node = do
  currentNodeIsError <- liftIO (TS.nodeIsError node)
  if currentNodeIsError
    then pure (SomeSymbolSing SErrorSymbol)
    else do
      currentNodeIsMissing <- liftIO (TS.nodeIsMissing node)
      if currentNodeIsMissing
        then pure (SomeSymbolSing SMissingSymbol)
        else do
          symbol <- liftIO (TS.nodeSymbol node)
          asks ((IM.! fromIntegral symbol) . unSymbolTable . symbolTable)

emitSomeNode :: NodeId -> SomeNode -> P SomeNode
emitSomeNode nodeId someNode = modify' updatePState >> pure someNode
 where
  updatePState pstate = pstate{newCache = insertSomeNode nodeId someNode (newCache pstate)}

lookupSomeNode :: NodeId -> P SomeNode
lookupSomeNode nodeId =
  maybe mzero pure . IM.lookup (unWrapTSNodeId nodeId) . unSomeNodeCache =<< asks oldCache

gotoParent :: P ()
gotoParent = do
  treeCursor <- asks treeCursor
  success <- liftIO (TS.treeCursorGotoParent treeCursor)
  if not success
    then mzero
    else do
      currentNode <- liftIO (TS.treeCursorCurrentNode treeCursor)
      putCurrentNode currentNode

gotoFirstNamedChild :: P ()
gotoFirstNamedChild = do
  treeCursor <- asks treeCursor
  success <- liftIO (TS.treeCursorGotoFirstChild treeCursor)
  if not success
    then mzero
    else do
      currentNode <- liftIO (TS.treeCursorCurrentNode treeCursor)
      currentNodeIsNamed <- liftIO (TS.nodeIsNamed currentNode)
      if currentNodeIsNamed
        then putCurrentNode currentNode
        else gotoNextNamedSibling

gotoNextNamedSibling :: P ()
gotoNextNamedSibling = do
  treeCursor <- asks treeCursor
  success <- liftIO (TS.treeCursorGotoNextSibling treeCursor)
  if not success
    then mzero
    else do
      currentNode <- liftIO (TS.treeCursorCurrentNode treeCursor)
      currentNodeIsNamed <- liftIO (TS.nodeIsNamed currentNode)
      if currentNodeIsNamed
        then putCurrentNode currentNode
        else gotoNextNamedSibling

--------------------------------------------------------------------------------
-- Parser Class
--------------------------------------------------------------------------------

class HasParser a where
  p :: P a

instance HasParser NodeId where
  p :: P NodeId
  p = TS.nodeId <$> getCurrentNode
instance HasParser (ChildList '[]) where
  p :: P (ChildList '[])
  p = pure Nil

instance (HasParser a) => HasParser (ChildList (a ': '[])) where
  p :: (HasParser a) => P (ChildList '[a])
  p = Cons <$> p <*> pure Nil

instance (HasParser a, HasParser (ChildList (b ': bs))) => HasParser (ChildList (a ': b ': bs)) where
  p :: (HasParser a, HasParser (ChildList (b : bs))) => P (ChildList (a ': b ': bs))
  p = Cons <$> p <* gotoNextNamedSibling <*> p

instance (HasParser (ChildList as)) => HasParser (Children as) where
  p :: (HasParser (ChildList as)) => P (Children as)
  p = Children <$> (gotoFirstNamedChild *> p <* gotoParent)

instance (HasParser a) => HasParser (Maybe a) where
  p :: (HasParser a) => P (Maybe a)
  p = optional p

instance (HasParser a) => HasParser [a] where
  p :: (HasParser a) => P [a]
  p = pPostFence p gotoNextNamedSibling

instance (HasParser a) => HasParser (NonEmpty a) where
  p :: (HasParser a) => P (NonEmpty a)
  p = pPostFence1 p gotoNextNamedSibling

instance HasParser Range where
  p :: P Range
  p = liftIO . TS.nodeRange =<< getCurrentNode

pPostFence :: P a -> P () -> P [a]
pPostFence post fence = postFence
 where
  fencePost = fence *> postFence <|> pure []
  postFence = ((:) <$> post <*> fencePost) <|> pure []

pPostFence1 :: P a -> P () -> P (NonEmpty a)
pPostFence1 post fence = postFence
 where
  fencePost = fence *> pPostFence post fence <|> pure []
  postFence = (:|) <$> post <*> fencePost

--------------------------------------------------------------------------------
-- Node Parser
--------------------------------------------------------------------------------

instance (KnownSort sort) => HasParser (Node sort) where
  p :: (KnownSort sort) => P (Node sort)
  p = pNode

pNode :: (KnownSort sort) => P (Node sort)
pNode =
  pSomeNode >>= \(SomeNode nodeContent) -> do
    let symbol = nodeContentToSymbol nodeContent
    let symbolType = symbolToSymbolType symbol
    case symbolType of
      SRegular ->
        pure $
          case decSortSing (symbolToSort symbol) sortSing of
            Just prf -> Node (RegularWellSorted prf) nodeContent
            Nothing -> SortMismatch (SomeNode nodeContent)
      SAuxiliary -> pure $ Node AuxiliaryWellSorted nodeContent

instance HasParser SomeNode where
  p :: P SomeNode
  p = pSomeNode

pSomeNode :: P SomeNode
pSomeNode = pSomeNode' =<< getCurrentNode
 where
  pSomeNode' :: TS.Node -> P SomeNode
  pSomeNode' node = emitSomeNode nodeId =<< tryCache <|> tryParse
   where
    nodeId = TS.nodeId node
    tryCache = do
      nodeHasChanges <- liftIO (TS.nodeHasChanges node)
      if nodeHasChanges then lookupSomeNode nodeId else mzero
    tryParse = do
      getSymbol node >>= \(SomeSymbolSing symbol) -> do
        -- grammarType <- liftIO (TS.nodeGrammarTypeAsString node)
        -- liftIO (printf "(%s %#x) -> %s\n" grammarType (unWrapTSNodeId nodeId) (show symbol))
        SomeNode <$> pNodeContent symbol

pNodeContent :: SymbolSing symbolType symbol -> P (NodeContent symbolType symbol)
pNodeContent = \case
{-+}
${for(dataTypes)}
${for(it.constrs)}
  S${it.name.camelCase}Symbol -> ${it.name.camelCase}Content <$$> p <*> p${if(it.hasChildren)} <*> p${endif}
${endfor}
${endfor}
{+-}
  SErrorSymbol -> ErrorContent <$> p <*> p <*> p
  SMissingSymbol -> MissingContent <$> p <*> p
  SSortMismatchSymbol -> SortMismatchContent <$> p
