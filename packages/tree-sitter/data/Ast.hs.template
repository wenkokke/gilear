-- WARNING: This module was generated by `tree-sitter-generate-ast`.
--
-- build-depends:
--   , base          >=4.13 && <5
--   , bytestring    >=0.12 && <0.13
--   , containers    >=0.6  && <0.8
--   , mtl           >=2.3  && <2.4
--   , transformers  >=0.6  && <0.7
--   , tree-sitter
--

{-# LANGUAGE DataKinds #-}
{-# LANGUAGE LambdaCase #-}
{-# LANGUAGE PatternSynonyms #-}
{-# LANGUAGE StandaloneKindSignatures #-}
{-# LANGUAGE TypeData #-}
{-# LANGUAGE TypeFamilies #-}
{-# LANGUAGE ImportQualifiedPost #-}
{-# LANGUAGE UndecidableInstances #-}

{-+}
module ${moduleName} (
{+-}
  Sort (..),
  SortSing (..),
  decSortSing,
  SymbolType (..),
  SymbolTypeSing (..),
  decSymbolTypeSing,
  Symbol (..),
  SymbolSing (..),
  decSymbolSing,
  symbolToSymbolType,
  SymbolToSort,
  symbolToSort,
  SomeSymbolSing (..),
  SymbolTable,
  mkSymbolTable,
  type (:<) (..),
  Node
  (
{-+}
${for(dataTypes)}
${for(it.constrs)}
    ${it.name.camelCase},
${endfor}${endfor}
{+-}
    Error,
    Missing,
    SortMismatch
  ),
  NodeContent (..),
  nodeContentToSymbol,
  Children (..),
  ChildList (..),
  SomeNode (..),
  SomeNodeCache,
  parseTree,
) where

import Control.Applicative (Alternative (..), optional)
import Control.Monad (MonadPlus (..))
import Control.Monad.IO.Class (MonadIO (..))
import Control.Monad.Reader (MonadReader, ReaderT (..), asks)
import Control.Monad.State.Strict (MonadState (..), StateT (..), modify', gets)
import Control.Monad.Trans.Maybe (MaybeT (..))
import Data.ByteString.Char8 qualified as BSC
import Data.IntMap.Strict (IntMap)
import Data.IntMap.Strict qualified as IM
import Data.Kind (Type)
import Data.List (intersperse)
import Data.List.NonEmpty (NonEmpty (..), toList)
import Data.Maybe (isJust)
import Data.Type.Equality (type (:~:) (..), type (:~~:) (..))
import TreeSitter (NodeId (..), Range (..))
import TreeSitter qualified as TS

--------------------------------------------------------------------------------
-- Entry point
--------------------------------------------------------------------------------

{-+}
parseTree :: SymbolTable -> TS.Tree -> IO (Maybe (Node ${startSort.camelCase}Sort, SomeNodeCache))
parseTree symbolTable tree = do
  rootNode <- TS.treeRootNode tree
  treeCursor <- TS.treeCursorNew rootNode
  let pEnv = PEnv symbolTable treeCursor mempty
  let pState = PState rootNode mempty
  (maybeNode, pState') <- runStateT (runMaybeT (runReaderT (unP p) pEnv)) pState
  pure $$ fmap (,newCache pState') maybeNode
{+-}

--------------------------------------------------------------------------------
-- Sort
--------------------------------------------------------------------------------

type data Sort where
{-+}
${for(dataTypes)}
  ${it.name.camelCase}Sort :: Sort
${endfor}
{+-}

data SortSing (sort :: Sort) where
{-+}
${for(dataTypes)}
  S${it.name.camelCase}Sort :: SortSing ${it.name.camelCase}Sort
${endfor}
{+-}

deriving instance Eq (SortSing sort)

deriving instance Show (SortSing sort)

decSortSing :: SortSing sort1 -> SortSing sort2 -> Maybe (sort1 :~: sort2)
{-+}
${for(dataTypes)}
decSortSing S${it.name.camelCase}Sort S${it.name.camelCase}Sort = Just Refl
${endfor}
{+-}
decSortSing _ _ = Nothing

class KnownSort sort where
  sortSing :: SortSing sort

{-+}
${for(dataTypes)}
instance KnownSort ${it.name.camelCase}Sort where
  sortSing = S${it.name.camelCase}Sort

${endfor}
{+-}

--------------------------------------------------------------------------------
-- SymbolType
--------------------------------------------------------------------------------

type data SymbolType where
  Regular :: SymbolType
  Auxiliary :: SymbolType

data SymbolTypeSing (symbolType :: SymbolType) where
  SRegular :: SymbolTypeSing Regular
  SAuxiliary :: SymbolTypeSing Auxiliary

deriving instance Eq (SymbolTypeSing symbolType)

deriving instance Show (SymbolTypeSing symbolType)

decSymbolTypeSing :: SymbolTypeSing symbolType1 -> SymbolTypeSing symbolType2 -> Maybe (symbolType1 :~: symbolType2)
decSymbolTypeSing SRegular SRegular = Just Refl
decSymbolTypeSing SAuxiliary SAuxiliary = Just Refl
decSymbolTypeSing _ _ = Nothing

--------------------------------------------------------------------------------
-- Symbol
--------------------------------------------------------------------------------

type data Symbol (symbolType :: SymbolType) where
{-+}
${for(dataTypes)}
${for(it.constrs)}
  ${it.name.camelCase}Symbol :: (symbolType ~ Regular) => Symbol symbolType
${endfor}
${endfor}
{+-}
  ErrorSymbol :: (symbolType ~ Auxiliary) => Symbol symbolType
  MissingSymbol :: (symbolType ~ Auxiliary) => Symbol symbolType
  SortMismatchSymbol :: (symbolType ~ Auxiliary) => Symbol symbolType

data SymbolSing (symbolType :: SymbolType) (symbol :: Symbol symbolType) where
{-+}
${for(dataTypes)}
${for(it.constrs)}
  S${it.name.camelCase}Symbol :: SymbolSing Regular ${it.name.camelCase}Symbol
${endfor}
${endfor}
{+-}
  SErrorSymbol :: SymbolSing Auxiliary ErrorSymbol
  SMissingSymbol :: SymbolSing Auxiliary MissingSymbol
  SSortMismatchSymbol :: SymbolSing Auxiliary SortMismatchSymbol

deriving instance Eq (SymbolSing sort symbol)

deriving instance Show (SymbolSing sort symbol)

decSymbolSing :: SymbolSing symbolType1 symbol1 -> SymbolSing symbolType2 symbol2 -> Maybe (symbolType1 :~: symbolType2, symbol1 :~~: symbol2)
{-+}
${for(dataTypes)}
${for(it.constrs)}
decSymbolSing S${it.name.camelCase}Symbol S${it.name.camelCase}Symbol = Just (Refl, HRefl)
${endfor}
${endfor}
{+-}
decSymbolSing _ _ = Nothing

data SomeSymbolSing
  = forall (symbolType :: SymbolType) (symbol :: Symbol symbolType).
    SomeSymbolSing !(SymbolSing symbolType symbol)

instance Eq SomeSymbolSing where
  SomeSymbolSing symbolSing1 == SomeSymbolSing symbolSing2 =
    isJust (decSymbolSing symbolSing1 symbolSing2)

deriving instance Show SomeSymbolSing

--------------------------------------------------------------------------------
-- Getting the symbol types for symbols
--------------------------------------------------------------------------------

symbolToSymbolType :: SymbolSing symbolType symbol -> SymbolTypeSing symbolType
symbolToSymbolType = \case
{-+}
${for(dataTypes)}
${for(it.constrs)}
  S${it.name.camelCase}Symbol -> SRegular
${endfor}
${endfor}
{+-}
  SErrorSymbol -> SAuxiliary
  SMissingSymbol -> SAuxiliary
  SSortMismatchSymbol -> SAuxiliary

--------------------------------------------------------------------------------
-- Inferring sorts for regular symbols
--------------------------------------------------------------------------------

type family SymbolToSort (symbol :: Symbol Regular) :: Sort where
{-+}
${for(dataTypes)}
${for(it.constrs)}
  SymbolToSort ${it.name.camelCase}Symbol = ${it.sort.camelCase}Sort
${endfor}
${endfor}
{+-}

symbolToSort :: SymbolSing Regular symbol -> SortSing (SymbolToSort symbol)
symbolToSort = \case
{-+}
${for(dataTypes)}
${for(it.constrs)}
  S${it.name.camelCase}Symbol -> S${it.sort.camelCase}Sort
${endfor}
${endfor}
{+-}

--------------------------------------------------------------------------------
-- Well-sortedness for symbols
--------------------------------------------------------------------------------

type (:<) :: forall (symbolType :: SymbolType). Symbol symbolType -> Sort -> Type
data (:<) symbol sort where
  AuxiliaryWellSorted ::
    forall (symbol :: Symbol Auxiliary) (sort :: Sort).
    symbol :< sort
  RegularWellSorted ::
    forall (symbol :: Symbol Regular) (sort :: Sort).
    !(SymbolToSort symbol :~: sort) ->
    symbol :< sort

deriving instance Eq (symbol :< sort)

deriving instance Show (symbol :< sort)

--------------------------------------------------------------------------------
-- Nodes
--------------------------------------------------------------------------------

data Node (sort :: Sort)
  = forall (symbolType :: SymbolType) (symbol :: Symbol symbolType).
  Node
  { nodeWellSorted :: !(symbol :< sort)
  , nodeContent :: !(NodeContent symbolType symbol)
  }

instance Eq (Node sort) where
  Node wellSorted1 content1 == Node wellSorted2 content2 =
    case nodeContentToSymbol content1 `decSymbolSing` nodeContentToSymbol content2 of
      Nothing -> False
      Just (Refl, HRefl) -> wellSorted1 == wellSorted2 && content1 == content2

deriving instance Show (Node sort)

data SomeNode
  = forall (symbolType :: SymbolType) (symbol :: Symbol symbolType).
  SomeNode
  { someNodeContent :: !(NodeContent symbolType symbol)
  }

instance Eq SomeNode where
  SomeNode content1 == SomeNode content2 =
    case nodeContentToSymbol content1 `decSymbolSing` nodeContentToSymbol content2 of
      Nothing -> False
      Just (Refl, HRefl) -> content1 == content2

deriving instance Show SomeNode

data NodeContent (symbolType :: SymbolType) (symbol :: Symbol symbolType) where
{-+}
${for(dataTypes)}
${for(it.constrs)}
  ${it.name.camelCase}Content ::
    !NodeId ->
    !Range ->
${if(it.hasChildren)}
    !(Children '[${for(it.fields)}${it.type}${sep}, ${endfor}]) ->  
${endif}
    NodeContent Regular ${it.name.camelCase}Symbol
${endfor}
${endfor}
{+-}
  ErrorContent ::
    !NodeId ->
    !Range ->
    !(Children '[[SomeNode]]) ->
    NodeContent Auxiliary ErrorSymbol
  MissingContent ::
    !NodeId ->
    !Range ->
    NodeContent Auxiliary MissingSymbol
  SortMismatchContent ::
    !SomeNode ->
    NodeContent Auxiliary SortMismatchSymbol

deriving instance Eq (NodeContent symbolType symbol)

deriving instance Show (NodeContent symbolType symbol)

nodeContentToSymbol ::
  forall (symbolType :: SymbolType) (symbol :: Symbol symbolType).
  NodeContent symbolType symbol ->
  SymbolSing symbolType symbol
nodeContentToSymbol = \case
{-+}
${for(dataTypes)}
${for(it.constrs)}
  ${it.name.camelCase}Content{} -> S${it.name.camelCase}Symbol
${endfor}
${endfor}
{+-}
  ErrorContent{} -> SErrorSymbol
  MissingContent{} -> SMissingSymbol
  SortMismatchContent{} -> SSortMismatchSymbol

--------------------------------------------------------------------------------
-- Node Children as Heterogeneous Lists
--------------------------------------------------------------------------------

data ChildList (as :: [Type]) :: Type where
  Nil :: ChildList '[]
  Cons :: !a -> !(ChildList as) -> ChildList (a ': as)

deriving instance Eq (ChildList '[])

deriving instance Show (ChildList '[])

deriving instance (Eq a, Eq (ChildList as)) => Eq (ChildList (a ': as))

deriving instance (Show a, Show (ChildList as)) => Show (ChildList (a ': as))

newtype Children as = Children (ChildList as)

deriving instance (Eq (ChildList as)) => Eq (Children as)

deriving instance (Show (ChildList as)) => Show (Children as)

--------------------------------------------------------------------------------
-- Pattern Synonyms
--------------------------------------------------------------------------------

{-+}
${for(dataTypes)}
${for(it.constrs)}
pattern ${it.name.camelCase} :: () => (sort ~ ${it.sort.camelCase}Sort) => NodeId -> Range -> ${if(it.hasChildren)}${for(it.fields)}${it.type} -> ${endfor}${endif} Node sort
pattern ${it.name.camelCase} nodeId nodeRange${if(it.hasChildren)}${for(it.fields)} nodeChild${it.index}${endfor}${endif} =
  Node (RegularWellSorted Refl) (${it.name.camelCase}Content nodeId nodeRange${if(it.hasChildren)} (Children${for(it.fields)} (Cons nodeChild${it.index}${endfor} Nil${for(it.fields)})${endfor})${endif})

${endfor}
${endfor}
{+-}

pattern Error :: NodeId -> Range -> [SomeNode] -> Node sort
pattern Error nodeId nodeRange nodeChild0 =
  Node AuxiliaryWellSorted (ErrorContent nodeId nodeRange (Children (Cons nodeChild0 Nil)))

pattern Missing :: NodeId -> Range -> Node sort
pattern Missing nodeId nodeRange =
  Node AuxiliaryWellSorted (MissingContent nodeId nodeRange)

pattern SortMismatch :: SomeNode -> Node sort
pattern SortMismatch nodeChild0 =
  Node AuxiliaryWellSorted (SortMismatchContent nodeChild0)

{-# COMPLETE
{-+}
${for(dataTypes)}
${for(it.constrs)}
  ${it.name.camelCase},
${endfor}${endfor}
{+-}
  Error,
  Missing,
  SortMismatch
  #-}

--------------------------------------------------------------------------------
-- Symbol Table
--------------------------------------------------------------------------------

newtype SymbolTable = SymbolTable {unSymbolTable :: IntMap SomeSymbolSing}

mkSymbolTable :: TS.Language -> IO SymbolTable
mkSymbolTable language =
  fmap (SymbolTable . IM.fromList) . sequence $
{-+}
${for(dataTypes/first)}
${for(it.constrs/first)}
    [ mkEntry "${it.name.text}" (SomeSymbolSing S${it.name.camelCase}Symbol)
${endfor}
${for(it.constrs/rest)}
    , mkEntry "${it.name.text}" (SomeSymbolSing S${it.name.camelCase}Symbol)
${endfor}
${endfor}
${for(dataTypes/rest)}
${for(it.constrs)}
    , mkEntry "${it.name.text}" (SomeSymbolSing S${it.name.camelCase}Symbol)
${endfor}
${endfor}
{+-}
    ]
 where
  mkEntry :: String -> SomeSymbolSing -> IO (Int, SomeSymbolSing)
  mkEntry grammarType someSymbol = do
    (,someSymbol) . fromIntegral <$> TS.languageSymbolForGrammarType language (BSC.pack grammarType) True

--------------------------------------------------------------------------------
-- Node Cache
--------------------------------------------------------------------------------

newtype SomeNodeCache = SomeNodeCache {unSomeNodeCache :: IntMap SomeNode}
  deriving (Show, Semigroup, Monoid)

insertSomeNode :: NodeId -> SomeNode -> SomeNodeCache -> SomeNodeCache
insertSomeNode nodeId someNode someNodeCacheMap =
  SomeNodeCache (IM.insert (unWrapTSNodeId nodeId) someNode (unSomeNodeCache someNodeCacheMap))

--------------------------------------------------------------------------------
-- Parser Monad
--------------------------------------------------------------------------------

data PState = PState
  { currentNode :: TS.Node
  , newCache :: !SomeNodeCache
  }

data PEnv = PEnv
  { symbolTable :: !SymbolTable
  , treeCursor :: !TS.TreeCursor
  , oldCache :: !SomeNodeCache
  }

newtype P a = P {unP :: ReaderT PEnv (MaybeT (StateT PState IO)) a}
  deriving (Functor, Applicative, Monad, MonadIO, MonadReader PEnv, MonadState PState, Alternative, MonadPlus)

getCurrentNode :: P TS.Node
getCurrentNode = gets currentNode

putCurrentNode :: TS.Node -> P ()
putCurrentNode node = modify' (\pstate -> pstate{currentNode = node})

getSymbol :: TS.Node -> P SomeSymbolSing
getSymbol node = do
  currentNodeIsError <- liftIO (TS.nodeIsError node)
  if currentNodeIsError
    then pure (SomeSymbolSing SErrorSymbol)
    else do
      currentNodeIsMissing <- liftIO (TS.nodeIsMissing node)
      if currentNodeIsMissing
        then pure (SomeSymbolSing SMissingSymbol)
        else do
          symbol <- liftIO (TS.nodeSymbol node)
          asks ((IM.! fromIntegral symbol) . unSymbolTable . symbolTable)

emitSomeNode :: NodeId -> SomeNode -> P SomeNode
emitSomeNode nodeId someNode = modify' updatePState >> pure someNode
 where
  updatePState pstate = pstate{newCache = insertSomeNode nodeId someNode (newCache pstate)}

lookupSomeNode :: NodeId -> P SomeNode
lookupSomeNode nodeId =
  maybe mzero pure . IM.lookup (unWrapTSNodeId nodeId) . unSomeNodeCache =<< asks oldCache

gotoParent :: P ()
gotoParent = do
  treeCursor <- asks treeCursor
  success <- liftIO (TS.treeCursorGotoParent treeCursor)
  if not success
    then mzero
    else do
      currentNode <- liftIO (TS.treeCursorCurrentNode treeCursor)
      putCurrentNode currentNode

gotoFirstNamedChild :: P ()
gotoFirstNamedChild = do
  treeCursor <- asks treeCursor
  success <- liftIO (TS.treeCursorGotoFirstChild treeCursor)
  if not success
    then mzero
    else do
      currentNode <- liftIO (TS.treeCursorCurrentNode treeCursor)
      currentNodeIsNamed <- liftIO (TS.nodeIsNamed currentNode)
      if currentNodeIsNamed
        then putCurrentNode currentNode
        else gotoNextNamedSibling

gotoNextNamedSibling :: P ()
gotoNextNamedSibling = do
  treeCursor <- asks treeCursor
  success <- liftIO (TS.treeCursorGotoNextSibling treeCursor)
  if not success
    then mzero
    else do
      currentNode <- liftIO (TS.treeCursorCurrentNode treeCursor)
      currentNodeIsNamed <- liftIO (TS.nodeIsNamed currentNode)
      if currentNodeIsNamed
        then putCurrentNode currentNode
        else gotoNextNamedSibling

--------------------------------------------------------------------------------
-- Parser Class
--------------------------------------------------------------------------------

class HasParser a where
  p :: P a

instance HasParser NodeId where
  p :: P NodeId
  p = TS.nodeId <$> getCurrentNode

instance HasParser (ChildList '[]) where
  p :: P (ChildList '[])
  p = pure Nil

instance (HasParser a) => HasParser (ChildList (a ': '[])) where
  p :: (HasParser a) => P (ChildList '[a])
  p = Cons <$> p <*> pure Nil

instance (HasParser a, HasParser (ChildList (b ': bs))) => HasParser (ChildList (a ': b ': bs)) where
  p :: (HasParser a, HasParser (ChildList (b : bs))) => P (ChildList (a ': b ': bs))
  p = Cons <$> p <* gotoNextNamedSibling <*> p

instance (HasParser (ChildList as)) => HasParser (Children as) where
  p :: (HasParser (ChildList as)) => P (Children as)
  p = Children <$> (gotoFirstNamedChild *> p <* gotoParent)

instance (HasParser a) => HasParser (Maybe a) where
  p :: (HasParser a) => P (Maybe a)
  p = optional p

instance (HasParser a) => HasParser [a] where
  p :: (HasParser a) => P [a]
  p = pPostFence p gotoNextNamedSibling

instance (HasParser a) => HasParser (NonEmpty a) where
  p :: (HasParser a) => P (NonEmpty a)
  p = pPostFence1 p gotoNextNamedSibling

instance HasParser Range where
  p :: P Range
  p = liftIO . TS.nodeRange =<< getCurrentNode

pPostFence :: P a -> P () -> P [a]
pPostFence post fence = postFence
 where
  fencePost = fence *> postFence <|> pure []
  postFence = ((:) <$> post <*> fencePost) <|> pure []

pPostFence1 :: P a -> P () -> P (NonEmpty a)
pPostFence1 post fence = postFence
 where
  fencePost = fence *> pPostFence post fence <|> pure []
  postFence = (:|) <$> post <*> fencePost

--------------------------------------------------------------------------------
-- Node Parser
--------------------------------------------------------------------------------

instance (KnownSort sort) => HasParser (Node sort) where
  p :: (KnownSort sort) => P (Node sort)
  p = pNode

pNode :: (KnownSort sort) => P (Node sort)
pNode =
  pSomeNode >>= \(SomeNode nodeContent) -> do
    let symbol = nodeContentToSymbol nodeContent
    let symbolType = symbolToSymbolType symbol
    case symbolType of
      SRegular ->
        pure $
          case decSortSing (symbolToSort symbol) sortSing of
            Just prf -> Node (RegularWellSorted prf) nodeContent
            Nothing -> SortMismatch (SomeNode nodeContent)
      SAuxiliary -> pure $ Node AuxiliaryWellSorted nodeContent

instance HasParser SomeNode where
  p :: P SomeNode
  p = pSomeNode

pSomeNode :: P SomeNode
pSomeNode = pSomeNode' =<< getCurrentNode
 where
  pSomeNode' :: TS.Node -> P SomeNode
  pSomeNode' node = emitSomeNode nodeId =<< tryCache <|> tryParse
   where
    nodeId = TS.nodeId node
    tryCache = do
      nodeHasChanges <- liftIO (TS.nodeHasChanges node)
      if nodeHasChanges then lookupSomeNode nodeId else mzero
    tryParse = do
      getSymbol node >>= \(SomeSymbolSing symbol) -> do
        -- grammarType <- liftIO (TS.nodeGrammarTypeAsString node)
        -- liftIO (printf "(%s %#x) -> %s\n" grammarType (unWrapTSNodeId nodeId) (show symbol))
        SomeNode <$> pNodeContent symbol

pNodeContent :: SymbolSing symbolType symbol -> P (NodeContent symbolType symbol)
pNodeContent = \case
{-+}
${for(dataTypes)}
${for(it.constrs)}
  S${it.name.camelCase}Symbol -> ${it.name.camelCase}Content <$$> p <*> p${if(it.hasChildren)} <*> p${endif}
${endfor}
${endfor}
{+-}
  SErrorSymbol -> ErrorContent <$> p <*> p <*> p
  SMissingSymbol -> MissingContent <$> p <*> p
  SSortMismatchSymbol -> SortMismatchContent <$> p

--------------------------------------------------------------------------------
-- Pretty Printing
--------------------------------------------------------------------------------

newtype SExp a = SExp {unSExp :: a}

instance (Show (SExp a)) => Show (SExp [a]) where
  showsPrec d = mconcat . intersperse (showString " ") . fmap (showsPrec d . SExp) . unSExp

instance (Show (SExp a)) => Show (SExp (NonEmpty a)) where
  showsPrec d = showsPrec d  . SExp . toList . unSExp

instance (Show (SExp a)) => Show (SExp (Maybe a)) where
  showsPrec d = maybe id (showsPrec d . SExp) . unSExp

instance Show (SExp (Node sort)) where
{-+}
${for(dataTypes)}
${for(it.constrs)}
  showsPrec d (SExp (${it.name.camelCase} _nodeId _nodeRange${if(it.hasChildren)}${for(it.fields)} nodeChild${it.index}${endfor}${endif})) =
    showParen (d > 10) (showString "${it.name.camelCase} "${if(it.hasChildren)}${for(it.fields)} . showsPrec 11 (SExp nodeChild${it.index})${endfor}${endif})
${endfor}
${endfor}
{+-}
  showsPrec d (SExp (Error _nodeId _nodeRange nodeChild0)) =
    showParen (d > 10) (showString "Error " . showsPrec 11 (SExp nodeChild0))
  showsPrec d (SExp (Missing _nodeId _nodeRange)) =
    showParen (d > 10) (showString "Missing")
  showsPrec d (SExp (SortMismatch nodeChild0)) =
    showParen (d > 10) (showString "SortMismatch " . showsPrec 11 (SExp nodeChild0))

instance Show (SExp SomeNode) where
  showsPrec d (SExp (SomeNode content)) =
    let symbol = nodeContentToSymbol content
        symbolType = symbolToSymbolType symbol
    in case symbolType of
        SRegular -> showsPrec d (SExp (Node (RegularWellSorted Refl) content))
        SAuxiliary -> showsPrec d (SExp (Node AuxiliaryWellSorted content))
